1. Mvc
2. Relationship
3. Eloquent query method
 Skip,  take, orderby,  where,  jason contens
4. Filtaring, searching, 
5. Php oop concept
6. function, static Trait,  interface, constant ,  abstract , extends , implements, composer ki
7. Objects, class ki kamne kaj kore
8. Design
9. Interview questions from google
 
10.  Namespace -> নেমস্পেস মুলত ডিরেক্টরি বা ফাইলের লোকেশন ।
*
11. What is Composer ?

12. Method chaining

13. Type hint  = func student(string $name) {}

14. Facade ki ?

15. Public:  Private: Protected
16. Service Provider,,  serivce container



$student->setName('obaydulla') =>  The -> symbol itself is called the object operator in PHP.
The :: symbol in PHP is called the scope resolution operator or sometimes the
class MyClass {
    const MY_CONSTANT = 'Hello';

    public static function myStaticMethod() {
        return 'This is a static method';
    }
}      

// Accessing a constant 
echo MyClass::MY_CONSTANT;  // Outputs:  Hello

// Accessing a static method
echo MyClass::myStaticMethod(); // Outputs: This is a static method

In this example, :: is used to access the constant MY_CONSTANT and the static method myStaticMethod within MyClass.

1. MVC
=================================================================================

MVC pattern মানে Model–view–controller

Model–view–controller হল একটি সফটওয়্যার ডেভেলপমেন্ট একটি জনপ্রিয় আদর্শ বা নমুনা ।
এই প্যাটার্নটি ব্যাবহার করা হয় সফটওয়্যারটি কে তিনটি ভাগে ভাগ করার জন্য।

Model: মডেলের কাজ হল ডাটাবেসের সাথে যোগাযোগ করা, যেমন কিছু ডেটা যোগ করা বা কিছু ডেটা মুছে ফেলা ডাটাবেস থেকে ।

View: view হল আমরা ওয়েব পেজে যা দেখি, এটি আমাদের ভিজ্যুয়াল অংশ। যেমন html css ।

Controller: Controller সবকিছু নিয়ন্ত্রণ করে, কি নিয়ন্ত্রণ করে ? এটি মডেল কে ব্যাবহার করে ডাটাবেস থেকে ডাটা নিয়ে আসে এবং view এর মাঝে ডাটা দিয়ে HTML response তৈরি করে এবং অবশেষে HTML response কে ব্রাউজার এ পাঠায় ।


২য় ভাগঃ লারাভেল এ MVC pattern এর ব্যাবহার

যখন আমরা লারাভেল অ্যাপ্লিকেশনে একটি request পাঠাই, তখন এই request (অনুরোধ ) টি প্রথমে রুট ফাইলে (web.php) যায় এবং রুট ফাইলটি অ্যাপোরিয়েট কন্ট্রোলারের কাছে এই request (অনুরোধ ) টি পাঠায়। controller তারপর model কে ব্যবহৃত করে ডেটাবেস থেকে ডেটা আনে এবং view থেকে HTML, CSS নিয়ে আসে । তারপর ডেটা , html, css দিয়ে controller একটি response প্রস্তুত করে ব্রাউজারে ফেরত পাঠানোর জন্য । যখন ব্রাউজার রিকোয়েস্টের পরে রিসপন্স ফিরে পায় তখন HTML পেজটি সঠিকভাবে প্রদর্শন করে এবং আমরা ওয়েব পেজ দেখতে পাই।

2. Relationship
========================================================================


1. One to One
------------------
Facebook Profile Picture


ধরো তুমি Facebook ব্যবহার করো। প্রত্যেক Facebook ব্যবহারকারীর একটি করে প্রোফাইল ছবি থাকে। এই প্রোফাইল ছবির সাথে তোমার বিশেষ সম্পর্ক থাকে, যেটা শুধুমাত্র তোমার। আর কেউ তোমার প্রোফাইল ছবির মালিক হতে পারে না। Laravel-এ এই সম্পর্ককে আমরা "One to One" সম্পর্ক বলি।

// User মডেল
class User extends Model {
    public function profilePicture() {
        return $this->hasOne(ProfilePicture::class);
    }
}

// ProfilePicture মডেল
class ProfilePicture extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}

এখানে, User মডেলে আমরা hasOne ব্যবহার করে দেখাচ্ছি যে, প্রত্যেক ব্যবহারকারীর একটি করে প্রোফাইল ছবি থাকতে পারে। আর ProfilePicture মডেলে belongsTo ব্যবহার করে দেখানো হয়েছে যে, প্রোফাইল ছবিটি একটি নির্দিষ্ট ব্যবহারকারীর সাথে সম্পর্কিত।


2. One to Many
--------------------------
 Facebook Posts


"One to Many" সম্পর্কের মূল কথা হলো, একটি একক মডেল (যেমন: User) অন্য একটি মডেলের (যেমন: Post) একাধিক ইনস্ট্যান্সের সাথে সম্পর্কিত হতে পারে। অর্থাৎ, একজন User অনেকগুলো Post তৈরি করতে পারে, কিন্তু প্রতিটি Post এর সাথে শুধুমাত্র একটি User যুক্ত থাকে।

উদাহরণ: Facebook-এ একজন ব্যবহারকারী (User) একাধিক পোস্ট (Post) করতে পারে। যেমন, তুমি প্রতিদিন অনেকগুলো পোস্ট করতে পারো, কিন্তু প্রতিটি পোস্টের মালিক তুমি একাই।

// User মডেল
class User extends Model {
    public function posts() {
        return $this->hasMany(Post::class);
    }
}

// Post মডেল
class Post extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}


hasMany: User মডেলে hasMany ফাংশনটি ব্যবহার করে জানাচ্ছে যে একজন User অনেকগুলো Post তৈরি করতে পারে।
belongsTo: Post মডেলে belongsTo ফাংশনটি ব্যবহার করে জানাচ্ছে যে প্রতিটি Post এর সাথে একটি নির্দিষ্ট User যুক্ত থাকে।




3. Many to One
---------------------------
 Facebook Posts and Comment

ধরো, Facebook-এ তুমি একটি পোস্ট করেছো। এখন অনেকেই তোমার পোস্টে মন্তব্য (Comment) করতে পারে। প্রতিটি মন্তব্য একাধিক ব্যবহারকারীর (User) হতে পারে, কিন্তু একটি মন্তব্যের সাথে শুধুমাত্র একটি পোস্ট যুক্ত থাকবে। অর্থাৎ, একাধিক মন্তব্য একটি নির্দিষ্ট পোস্টের অধীনে থাকবে।

এটা Laravel-এর "Many to One" সম্পর্ক বোঝায়।

// Post মডেল
class Post extends Model {
    public function comments() {
        return $this->hasMany(Comment::class);
    }
}

// Comment মডেল
class Comment extends Model {
    public function post() {
        return $this->belongsTo(Post::class);
    }
}

এখানে, Post মডেলে hasMany ফাংশন ব্যবহার করে দেখানো হয়েছে যে, একটি পোস্টের অধীনে অনেকগুলো মন্তব্য থাকতে পারে। অন্যদিকে, Comment মডেলে belongsTo ফাংশন ব্যবহার করে দেখানো হয়েছে যে, প্রতিটি মন্তব্য শুধুমাত্র একটি পোস্টের সাথে সম্পর্কিত।


4. Many to Many
-----------------------
Facebook Groups & Users

Many to Many সম্পর্ক হলো, দুটি মডেল একে অপরের সাথে একাধিক ইনস্ট্যান্সের মাধ্যমে সম্পর্কিত হতে পারে। অর্থাৎ, একটি মডেল অনেকগুলোর সাথে সম্পর্কিত হতে পারে, এবং সেই মডেলগুলোও অনেকগুলোর সাথে সম্পর্কিত হতে পারে।

উদাহরণ: Facebook Groups & Users
ধরো, Facebook-এ অনেকগুলো গ্রুপ (Group) আছে, এবং একজন ব্যবহারকারী (User) একাধিক গ্রুপে যোগ দিতে পারে। আবার, একটি গ্রুপে অনেকগুলো ব্যবহারকারী থাকতে পারে। এখানে User এবং Group এর মধ্যে "Many to Many" সম্পর্ক থাকে।
}

// User মডেল
class User extends Model {
    public function groups() {
        return $this->belongsToMany(Group::class);
    }
}

// Group মডেল
class Group extends Model {
    public function users() {
        return $this->belongsToMany(User::class);
    }
}

Many to Many সম্পর্ক হলো, একটি মডেল (যেমন User) অনেকগুলোর (যেমন Group) সাথে সম্পর্কিত হতে পারে, এবং সেই মডেলগুলোও (যেমন Group) অনেকগুলোর (যেমন User) সাথে সম্পর্কিত হতে পারে।
এখানে Laravel-এর belongsToMany ফাংশন ব্যবহার করা হয় এই সম্পর্কটি তৈরি করার জন্য।




5. Has Many Through
-------------------------------
 Countries -> Users -> Posts

Imagine your grandparents have many grandchildren through their children (your parents). In Laravel, this is called a "Has Many Through" relationship. It means you can find a connection through another person.


ধরো, তুমি একটি ওয়েবসাইট তৈরি করছো যেখানে ব্যবহারকারীরা বিভিন্ন দেশ থেকে আসে এবং পোস্ট করে। এখানে প্রতিটি দেশ (Country) অনেকগুলো ব্যবহারকারী (User) আছে, এবং প্রতিটি ব্যবহারকারী অনেকগুলো পোস্ট (Post) করতে পারে। এখানে "Has Many Through" সম্পর্ক ব্যবহার করে আমরা Country মডেল থেকে সরাসরি Post মডেলে সম্পর্ক তৈরি করতে পারি।

সংক্ষেপে: 
 "Has Many Through" সম্পর্ক হলো এমন একটি সম্পর্ক যেখানে প্রথম মডেল দ্বিতীয় মডেলের মাধ্যমে তৃতীয় মডেলের সাথে সংযুক্ত থাকে।


// Country মডেল
class Country extends Model {
    public function posts() {
        return $this->hasManyThrough(Post::class, User::class);
    }
}

// User মডেল
class User extends Model {
    public function posts() {
        return $this->hasMany(Post::class);
    }
}

// Post মডেল
class Post extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}



countries
    id - integer
    name - string
users
    id - integer
    country_id - integer
    name - string
posts
    id - integer
    user_id - integer
    title - string
Has Many Through সম্পর্ক হলো, একটি মডেল (যেমন Country) একটি মধ্যস্থ মডেলের (যেমন User) মাধ্যমে তৃতীয় একটি মডেলের (যেমন Post) সাথে সম্পর্কিত।
এখানে Country মডেল User মডেলের মাধ্যমে Post মডেলের সাথে সম্পর্কিত, যার মাধ্যমে আমরা একটি দেশ থেকে সরাসরি তার সমস্ত পোস্ট দেখতে পারি।


6. Polymorphic Relations
--------------------------------

OOP Concept
-----------------

পলিমরফিজম (Polymorphism) হলো প্রোগ্রামিংয়ের একটি ধারণা, যেখানে একই নামের মেথড বা ফাংশন বিভিন্ন ধরণের কাজ করতে পারে। সহজভাবে বললে, পলিমরফিজমের মাধ্যমে আমরা একই মেথডের মাধ্যমে ভিন্ন ভিন্ন ধরণের অবজেক্টকে আলাদা ভাবে ব্যবহার করতে পারি।

<?php
class ParentClass {
    public function makeCake() {
        echo "Making a simple cake.";
    }
}

class ChildClass extends ParentClass {
    public function makeCake() {
        echo "Making a cake with chocolate!";
    }
}

$cake1 = new ParentClass();
$cake2 = new ChildClass();

$cake1->makeCake(); // এটা প্রিন্ট করবে: "Making a simple cake."
$cake2->makeCake(); // এটা প্রিন্ট করবে: "Making a cake with chocolate!"
?>


Relationsshop Concept
----------------------------------

পলিমোরফিক সম্পর্ক (Polymorphic Relationship) কীভাবে কাজ করে?
পলিমোরফিক সম্পর্ক এমন একটি সম্পর্ক যেখানে একটি মডেল অন্য একাধিক মডেলের সাথে সম্পর্ক স্থাপন করতে পারে একটি সাধারণ টেবিল ব্যবহার করে।

টেবিল সেটআপ:

posts টেবিলে পোস্টের তথ্য থাকে।
videos টেবিলে ভিডিওগুলির তথ্য থাকে।
comments টেবিলে সমস্ত কমেন্টের তথ্য থাকে, এবং commentable_id ও commentable_type কলামগুলি পোস্ট বা ভিডিও থেকে কোনটি সম্পর্কিত তা নির্দেশ করে।

Comment মডেলে morphTo মেথড ব্যবহার করা হয়েছে যা কমেন্টটি কোন মডেলের সাথে সম্পর্কিত তা নির্ধারণ করে।
Post এবং Video মডেলগুলোতে morphMany মেথড ব্যবহার করা হয়েছে, যা পোস্ট বা ভিডিওর সমস্ত কমেন্টকে ফেচ করতে সাহায্য করে।

posts
    id - integer
    title - string
    body - text

videos
    id - integer
    title - string
    url - string

comments
    id - integer
    body - text
    commentable_id - integer
    commentable_type - string

commentable_id এখানে সেভ হবে posts/videos id এবং commentable_type এ থাকবে টাইপ post অথবা video ।

এখন Model কেমন হবে দেখুন

<?php
namespace App;
use Illuminate\Database\Eloquent\Model;

class Comment extends Model
{
    /**
     * Get all of the owning commentable models.
     * 
     * এই মেথডটি Comment মডেলটিকে কোন মডেলের সাথে সম্পর্কিত তা নির্দেশ করে।
     */
    public function commentable()
    {
        return $this->morphTo();
    }
}

class Post extends Model
{
    /**
     * Get all of the post's comments.
     * 
     * এই মেথডটি পোস্টের সাথে সম্পর্কিত সকল কমেন্টকে ফেরত দেয়।
     */
    public function comments()
    {
        return $this->morphMany('App\Comment', 'commentable');
    }
}

class Video extends Model
{
    /**
     * Get all of the video's comments.
     * 
     * এই মেথডটি ভিডিওর সাথে সম্পর্কিত সকল কমেন্টকে ফেরত দেয়।
     */
    public function comments()
    {
        return $this->morphMany('App\Comment', 'commentable');
    }
}

কিভাবে কাজ করবে:
যখনই আপনি একটি পোস্ট বা ভিডিওতে কমেন্ট করবেন, comments টেবিলে নতুন রেকর্ড যুক্ত হবে যেখানে commentable_id হবে পোস্ট বা ভিডিওর আইডি, এবং commentable_type হবে 'App\Post' বা 'App\Video'।
এই সেটআপের মাধ্যমে একটি মাত্র কমেন্ট টেবিল ব্যবহার করে বিভিন্ন ধরনের মডেলের সাথে সম্পর্ক তৈরি করা যায়, যা ডেটাবেসকে সুশৃঙ্খল ও সহজে ব্যবস্থাপিত রাখে।

$post = Post::find(1);
$comment = new Comment(['body' => 'This is a comment on a post.']);
$post->comments()->save($comment);

$video = Video::find(1);
$comment = new Comment(['body' => 'This is a comment on a video.']);
$video->comments()->save($comment);








3. Eloquent query method
================================================================================
Eloquent is an object-relational mapper (ORM)
Eloquent models represent database tables.
Models can be used to perform operations on data
Eloquent also supports relationships between models
It provides layer between application and databas

Naming Convention
----------------------------
Table name: brands Model name: Brand
Table name: product_details Model name: ProductDetails

Skip,  take, orderby,  where jason contens

**Skip and take method : skip method diye koita data skip korbo seta likte hobe r take method diye koita data nibo seta likte hobe .
example: 

student::skip(2)->take(4)->get();

 ** orderby :
-------------

asc (Ascending):
---------------------------
Numerical Order: From the smallest number to the largest (e.g., 1, 2, 3, ..., 10).
Alphabetical Order: From A to Z.
Date Order: From the earliest date to the latest date.

desc (Descending):
-------------------------
Numerical Order: From the largest number to the smallest (e.g., 10, 9, 8, ..., 1).
Alphabetical Order: From Z to A.
Date Order: From the latest date to the earliest date.

$users = User::orderBy('name', 'asc')->get();
	This query retrieves users ordered by their names in ascending alphabetical order (A to Z).

$products = Product::orderBy('price', 'asc')->get();
	This query retrieves products ordered by their price in ascending order (cheapest to most expensive).

$users = User::orderBy('created_at', 'desc')->get();
	This query retrieves users ordered by their creation date in descending order (newest to oldest).



** where 
-------------------
$animalBooks = AnimalBook::where('pages', '>', 100)->get();

$animalBooksByJohnDoe = AnimalBook::where('author', 'John Doe')
                                   ->where('pages', '>', 100)
                                   ->get();

$userId = 1; // Assuming 1 is the ID of the specific user
$userPosts = Post::where('user_id', $userId)->get();
class PostController extends Controller
{
    public function index()
    {
        $userId = 1; // Assuming 1 is the ID of the specific user
        $filteredPosts = Post::where('published_at', '>', '2023-01-01')
                             ->where('user_id', $userId)
                             ->whereHas('comments', function ($query) {
                                 $query->havingRaw('COUNT(*) > 10');
                             })
                             ->get();
        
        return view('posts.index', ['posts' => $filteredPosts]);
    }
}

<?php

// 1. Retrieve All Records
// Retrieves all records from the 'users' table.
$users = User::all();

// 2. Find a Record by Primary Key
// Retrieves the record with id 1 from the 'users' table.
$user = User::find(1);

// 3. Where Clauses
// Retrieves all users where the 'status' column is 'active'.
$users = User::where('status', 'active')->get();

// 4. Retrieve Single Record
// Retrieves the first user with the email 'example@example.com'.
$user = User::where('email', 'example@example.com')->first();

// 5. Pluck Columns
// Retrieves all user names from the 'users' table.
$userNames = User::pluck('name');

// 6. Order By
// Retrieves all users ordered by their 'name' in ascending order.
$users = User::orderBy('name', 'asc')->get();

// 7. Limit and Offset
// Retrieves 10 users, starting from the 6th user (offset 5).
$users = User::limit(10)->offset(5)->get();

// 8. Pagination
// Retrieves 15 users per page with pagination links.
$users = User::paginate(15);

// 9. Join Tables
// Retrieves users along with their post titles by joining the 'posts' table.
$users = User::join('posts', 'users.id', '=', 'posts.user_id')
             ->select('users.*', 'posts.title')
             ->get();

// 10. Eager Loading
// Retrieves all users along with their associated posts in a single query.
$users = User::with('posts')->get();

// 11. Has Many Through
// Assuming you have a 'Country' model with a 'posts' relationship,
// retrieves all posts for the country with id 1.
$posts = Country::find(1)->posts;

// 12. Combining Methods
// Retrieves the first 10 active users ordered by name in ascending order.
$users = User::where('status', 'active')
             ->orderBy('name', 'asc')
             ->limit(10)
             ->get();

?>




**  jason contens
-----------------------
<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Models\Profile;

// 1. JSON রেসপন্স
// এই রুটটি একটি JSON রেসপন্স প্রদান করে যা ব্যবহারকারীর বিস্তারিত তথ্য ধারণ করে।
Route::get('/json-example', function () {
    // JSON হিসেবে ফেরত দেওয়ার জন্য ডেটা নির্ধারণ করা হয়েছে
    $data = [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'age' => 30
    ];

    // JSON রেসপন্স হিসেবে ডেটা ফেরত দেওয়া হয়েছে
    return response()->json($data);
});

// 2. JSON ডেটা গ্রহণ
// এই রুটটি একটি POST রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করে এবং তা ফেরত দেয়।
Route::post('/json-receive', function (Request $request) {
    // রিকোয়েস্ট থেকে সমস্ত JSON ডেটা গ্রহণ করা হয়েছে
    $data = $request->json()->all();

    // প্রাপ্ত ডেটা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'received_data' => $data
    ]);
});

// 3. JSON রিকোয়েস্ট থেকে নির্দিষ্ট মান নেওয়া
// এই রুটটি POST রিকোয়েস্ট থেকে JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করে।
Route::post('/json-value', function (Request $request) {
    // JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করা হয়েছে
    $name = $request->input('name');
    $email = $request->input('email');

    // প্রাপ্ত মান JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'name' => $name,
        'email' => $email
    ]);
});

// 4. JSON ডেটা ডেটাবেসে সেভ করা
// এই রুটটি JSON ডেটা ডেটাবেসে 'preferences' কলামে সংরক্ষণ করে।
Route::post('/save-preferences', function (Request $request) {
    // রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করা হয়েছে
    $preferences = $request->json()->get('preferences');

    // নতুন একটি Profile ইনস্ট্যান্স তৈরি করা হয়েছে এবং JSON ডেটা সেভ করা হয়েছে
    $profile = new Profile();
    $profile->preferences = $preferences;
    $profile->save();

    // সফলতার বার্তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'message' => 'Preferences saved successfully!'
    ]);
});

// 'profiles' টেবিল তৈরি করার জন্য মাইগ্রেশন
// JSON কলামসহ ডেটাবেস টেবিল তৈরি করার জন্য মাইগ্রেশন উদাহরণ
Schema::create('profiles', function (Blueprint $table) {
    $table->id(); // অটো-ইনক্রিমেন্ট আইডি
    $table->json('preferences'); // JSON কলাম যা JSON ডেটা সংরক্ষণ করবে
    $table->timestamps(); // তৈরি হওয়া এবং আপডেট হওয়ার সময়
});
?>

JSON রেসপন্স
------------
Route::get('/json-example', function () {
    $data = [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'age' => 30
    ];

    return response()->json($data);
});

JSON ডেটা গ্রহণ
---------------------
Route::post('/json-receive', function (Request $request) {
    $data = $request->json()->all();

    return response()->json([
        'received_data' => $data
    ]);
});

উদ্দেশ্য: POST রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করা এবং তা ফেরত দেওয়া।
কিভাবে কাজ করে: $request->json()->all() মেথড ব্যবহার করে সমস্ত JSON ডেটা গ্রহণ করা হয়েছে এবং তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।


SON রিকোয়েস্ট থেকে নির্দিষ্ট মান নেওয়া
-------------------------------------
Route::post('/json-value', function (Request $request) {
    $name = $request->input('name');
    $email = $request->input('email');

    return response()->json([
        'name' => $name,
        'email' => $email
    ]);
});

উদ্দেশ্য: POST রিকোয়েস্ট থেকে JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করা।
কিভাবে কাজ করে: $request->input('name') এবং $request->input('email') মেথড ব্যবহার করে নির্দিষ্ট মান গ্রহণ করা হয়েছে এবং তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।


JSON ডেটা ডেটাবেসে সেভ করা
Route::post('/save-preferences', function (Request $request) {
    $preferences = $request->json()->get('preferences');

    $profile = new Profile();
    $profile->preferences = $preferences;
    $profile->save();

    return response()->json([
        'message' => 'Preferences saved successfully!'
    ]);
});
উদ্দেশ্য: JSON ডেটা ডেটাবেসে সংরক্ষণ করা।
কিভাবে কাজ করে: রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করে preferences কলামে সেভ করা হয়েছে এবং সফলতার বার্তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।

মাইগ্রেশন
----------------
Schema::create('profiles', function (Blueprint $table) {
    $table->id(); // অটো-ইনক্রিমেন্ট আইডি
    $table->json('preferences'); // JSON কলাম
    $table->timestamps(); // তৈরি হওয়া এবং আপডেট হওয়ার সময়
});

উদ্দেশ্য: JSON কলামসহ ডেটাবেস টেবিল তৈরি করা।
কিভাবে কাজ করে: profiles টেবিল তৈরি করার জন্য মাইগ্রেশন ব্যবহার করা হয়েছে, যেখানে preferences কলামটি JSON ডেটা সংরক্ষণের জন্য ব্যবহৃত হবে।








6. function, static, Trait, abstract, interface, constant , , extends , implements
==================================================================
Function
---------------

What is a PHP Function?
A function in PHP is a block of code that can be executed whenever it is called within a script. It can take input in the form of parameters and can return a value after performing its task.

PHP ফাংশন হল কোডের একটি ব্লক যা নির্দিষ্ট একটি কাজ সম্পন্ন করে। ফাংশন ব্যবহার করলে একই কোড বারবার লেখার দরকার হয় না। এখানে PHP ফাংশনের একটি উদাহরণ দেওয়া হলো:

<?php

// ফাংশন ডিফাইন করা হয়েছে
function greet($name) {
    // এখানে $name প্যারামিটার হিসেবে নেওয়া হয়েছে এবং একটি শুভেচ্ছা বার্তা প্রদর্শন করা হয়েছে
    return "Hello, " . $name . "!";
}

// ফাংশন কল করা হচ্ছে এবং "John" নাম পাঠানো হচ্ছে
echo greet("John"); // আউটপুট: Hello, John!

// ফাংশন আবার কল করা হচ্ছে এবং "Alice" নাম পাঠানো হচ্ছে
echo greet("Alice"); // আউটপুট: Hello, Alice!

?>

ফাংশন ডিফাইন করা: greet() নামে একটি ফাংশন তৈরি করা হয়েছে যা $name নামে একটি প্যারামিটার গ্রহণ করে।
ফাংশন কাজ: ফাংশনটি $name প্যারামিটারকে "Hello, " স্ট্রিং-এর সাথে যুক্ত করে এবং একটি শুভেচ্ছা বার্তা রিটার্ন করে।
ফাংশন কল করা: greet("John") এবং greet("Alice") কল করা হলে, ফাংশনটি সংশ্লিষ্ট নামের জন্য শুভেচ্ছা বার্তা প্রদান করবে।
এই ফাংশনটি একাধিক বার ব্যবহার করা যেতে পারে বিভিন্ন নামের জন্য শুভেচ্ছা বার্তা প্রদানের উদ্দেশ্যে।

Anonymous Function
-----------------------------------
PHP-তে অ্যানোনিমাস ফাংশন হলো একটি ফাংশন যার কোনো নাম নেই। এই ধরনের ফাংশনকে ক্লোজারও বলা হয় এবং সাধারণত একবারের জন্য ব্যবহৃত হয়। অ্যানোনিমাস ফাংশনকে একটি ভেরিয়েবলের মধ্যে সংরক্ষণ করা যায় এবং পরে যেখানে প্রয়োজন সেখানে ব্যবহার করা যায়।

<?php

// অ্যানোনিমাস ফাংশন তৈরি করা হয়েছে এবং $greet ভেরিয়েবলের মধ্যে সংরক্ষণ করা হয়েছে
$greet = function($name) {
    // এখানে $name প্যারামিটার হিসেবে নেওয়া হয়েছে এবং একটি শুভেচ্ছা বার্তা প্রদর্শন করা হয়েছে
    return "Hello, " . $name . "!";
};

// অ্যানোনিমাস ফাংশন কল করা হচ্ছে এবং "John" নাম পাঠানো হচ্ছে
echo $greet("John"); // আউটপুট: Hello, John!

// অ্যানোনিমাস ফাংশন আবার কল করা হচ্ছে এবং "Alice" নাম পাঠানো হচ্ছে
echo $greet("Alice"); // আউটপুট: Hello, Alice!

?>



Parameters: Functions can accept parameters to work with dynamic data.
Anonymous Functions: Functions without a name that can be assigned to variables.


static 
--------------

 * স্ট্যাটিক প্রোপার্টি এবং মেথডকে স্ট্যাটিক করতে হলে, তাদের নামের পূর্বে অবশ্যই static কীওয়ার্ডটি লিখতে হয়।
 * স্ট্যাটিক মেথডকেসরাসরি ক্লাসের নাম ব্যবহার করে এবং :: অপারেটর দিয়ে কল করা উচিত। 
 * স্ট্যাটিক মেথড ব্যবহারের জন্য ক্লাসের ইনস্ট্যান্স তৈরি করার প্রয়োজন হয় না।
 

<?php

class Dev {
    const AGE = 50;
    const NAME = "Obaydulla";
    public static $name = "Obaydulla";

    public static function name() {
        return "My name is " . self::NAME; // এখানে Dev::NAME এর পরিবর্তে self::NAME ব্যবহার করা হয়েছে
    }
}

// স্ট্যাটিক মেথড কল করা হচ্ছে, ক্লাসের নাম ব্যবহার করে
echo Dev::name(); // আউটপুট: My name is Obaydulla

// স্ট্যাটিক প্রোপার্টি অ্যাক্সেস করা হচ্ছে
echo Dev::$name; // আউটপুট: Obaydulla

?>
মূল বিষয়গুলি:
স্ট্যাটিক মেথড অ্যাক্সেস:

Dev::name() দিয়ে সরাসরি মেথড কল করা হয়েছে।
ক্লাসের ইনস্ট্যান্স তৈরি করার প্রয়োজন নেই।
স্ট্যাটিক প্রোপার্টি অ্যাক্সেস:

Dev::$name দিয়ে সরাসরি প্রোপার্টি অ্যাক্সেস করা হয়েছে।



* Trait
-------------
Trait-এর মূল বৈশিষ্ট্য:
Trait হলো এমন একটি মেকানিজম যা PHP-তে মাল্টিপল ইনহেরিটেন্সের সুবিধা দেয়।
Trait ক্লাসের ভেতরে use কীওয়ার্ড ব্যবহার করে ইনক্লুড করা হয়।
একটি ক্লাস একাধিক Trait ব্যবহার করতে পারে।

Example:- 
<?php

// Trait তৈরি করা হয়েছে
trait SayHello {
    public function sayHello() {
        echo "Hello, World!";
    }
}

// Trait তৈরি করা হয়েছে
trait SayGoodbye {
    public function sayGoodbye() {
        echo "Goodbye, World!";
    }
}

// Greeter ক্লাস যেখানে SayHello এবং SayGoodbye Trait ব্যবহার করা হয়েছে
class Greeter {
    use SayHello, SayGoodbye;
}

// Greeter ক্লাসের একটি ইনস্ট্যান্স তৈরি করা হয়েছে
$greeter = new Greeter();

// Trait এর মেথডগুলো ব্যবহার করা হচ্ছে
$greeter->sayHello();   // আউটপুট: Hello, World!
$greeter->sayGoodbye(); // আউটপুট: Goodbye, World!

?>

Trait তৈরি করা:

SayHello নামে একটি Trait তৈরি করা হয়েছে যা sayHello() নামে একটি মেথড ধারণ করে। এই মেথডটি "Hello, World!" প্রিন্ট করবে।
SayGoodbye নামে আরেকটি Trait তৈরি করা হয়েছে যা sayGoodbye() মেথড ধারণ করে, এটি "Goodbye, World!" প্রিন্ট করবে।
Trait ব্যবহার করা:

Greeter নামে একটি ক্লাস তৈরি করা হয়েছে যেখানে use SayHello, SayGoodbye; ব্যবহার করে দুটি Trait ইনক্লুড করা হয়েছে।
Trait থেকে মেথড কল করা:

Greeter ক্লাসের একটি ইনস্ট্যান্স $greeter তৈরি করা হয়েছে।
$greeter->sayHello(); কল করা হলে, এটি SayHello Trait থেকে sayHello() মেথডটি চালাবে এবং "Hello, World!" প্রিন্ট করবে।
$greeter->sayGoodbye(); কল করা হলে, এটি SayGoodbye Trait থেকে sayGoodbye() মেথডটি চালাবে এবং "Goodbye, World!" প্রিন্ট করবে।




* abstract, 
-------------------
এবস্ট্রাক্ট ক্লাস এবং মেথড:

এবস্ট্রাক্ট ক্লাস: এই ধরনের ক্লাস থেকে সরাসরি কোনো ইনস্ট্যান্স তৈরি করা যায় না (মানে, এই ক্লাসটি দিয়ে সরাসরি কোনো অবজেক্ট বানানো যায় না)। তবে এটি অন্য ক্লাসগুলোর মধ্যে ইনহেরিট করা যায়, অর্থাৎ, এর চাইল্ড ক্লাস হিসেবে ব্যবহার করা যায়।

এবস্ট্রাক্ট মেথড: এটি শুধুমাত্র একটি নকশা বা নির্দেশনা দেয়, কিন্তু এর ভেতরে কোনো কোড বা কাজের বিবরণ থাকে না। চাইল্ড ক্লাসগুলোতে এই মেথডের বাস্তবায়ন (implementation) করতে হয়।

এবস্ট্রাক্ট ক্লাস প্রোগ্রামারদের নির্দেশনা দেয় যে, চাইল্ড ক্লাসগুলোতে কি কি থাকতে হবে। এটি প্রোগ্রামিংয়ের একটি ধরণ বা গাইডলাইন হিসেবে কাজ করে।

abstract class Animal {
    // এবস্ট্রাক্ট মেথড, যার কোনো নির্দিষ্ট কাজ নেই
    abstract public function sound();
}

class Dog extends Animal {
    // Dog ক্লাসে sound() মেথডের বাস্তবায়ন
    public function sound() {
        return "Bark";
    }
}

class Cat extends Animal {
    // Cat ক্লাসে sound() মেথডের বাস্তবায়ন
    public function sound() {
        return "Meow";
    }
}

// Dog এবং Cat ক্লাসের ইনস্ট্যান্স তৈরি করা যাবে
$dog = new Dog();
echo $dog->sound(); // Output: Bark

$cat = new Cat();
echo $cat->sound(); // Output: Meow

সহজভাবে বললে:
এবস্ট্রাক্ট ক্লাস (Animal): এটি একটি নকশা বা ধারণা, যা বলছে, "যে কোনো প্রাণীকে একটি sound() মেথড থাকতে হবে।"
Dog এবং Cat: এরা Animal থেকে ইনহেরিট করা ক্লাস। Dog ঘেউ ঘেউ করে (Bark) এবং Cat মিউ মিউ করে (Meow)।

* interface
-------------------
ইন্টারফেস ক্লাস (Interface Class) : এর আগে এবস্ট্রাক্ট ক্লাস সম্পর্কে আলোচনা হয়েছে।এবস্ট্রাক্ট ক্লাস আর ইন্টারফেস ক্লাস হুবহু একই শুধু পার্থক্য হচ্ছে এবস্ট্রাক্ট ক্লাসে এবস্ট্রাক্ট মেথড ছাড়াও অন্য মেথড থাকতে পারে এবং এই মেথডের ভিতর কোড থাকতে পারে (সাধারনত এটাকে মেথড বডি বলে) আর ইন্টারফেস ক্লাসে কোন মেথডে বডি থাকতে পারবেনা।

interface onno onno class ke baddo kore kaj korar jonno...... aikhane method mody thakbe na eta implements  korte hoi not extends

example....
interface Student {
    public function dev($name, $age);
}

class Users implements Student {
    function dev($name, $age) {
        echo "I am " .$name . $age;
    }
}

$dev = new Users;

$dev->dev('interface', 20);




 * constant  ধ্রুবক মানে যা কোন পরিবর্তন নেই ।
-------------------------------------------------------

PHP-তে Constant (কনস্ট্যান্ট) হলো এমন একটি ভেরিয়েবল যার মান (value) একবার সেট করলে তা আর পরিবর্তন করা যায় না। কনস্ট্যান্টের মান স্ক্রিপ্ট চলাকালীন স্থির থাকে এবং পরবর্তীতে পরিবর্তন করা যায় না। সাধারণত, যেসব মান পরিবর্তন করা প্রয়োজন হয় না, সেগুলো কনস্ট্যান্ট হিসেবে ডিফাইন করা হয়।

কনস্ট্যান্ট তৈরি করার নিয়ম:
define() ফাংশন ব্যবহার করে:
define('CONSTANT_NAME', value); এর মাধ্যমে কনস্ট্যান্ট ডিফাইন করা হয়।
const কীওয়ার্ড ব্যবহার করে:
const CONSTANT_NAME = value; দিয়ে কনস্ট্যান্ট ডিফাইন করা হয় (এটি ক্লাসের মধ্যে ব্যবহৃত হয়)।

উদাহরণ ১: define() ফাংশন ব্যবহার করে কনস্ট্যান্ট ডিফাইন করা
<?php

// কনস্ট্যান্ট ডিফাইন করা হয়েছে
define('SITE_NAME', 'My Website');

// কনস্ট্যান্ট ব্যবহার করা হচ্ছে
echo SITE_NAME; // আউটপুট: My Website

?>
উদাহরণ ২: const কীওয়ার্ড ব্যবহার করে কনস্ট্যান্ট ডিফাইন করা
<?php

class Config {
    // কনস্ট্যান্ট ডিফাইন করা হয়েছে
    const DB_HOST = 'localhost';
    const DB_USER = 'root';
    const DB_PASS = 'password';
}

// কনস্ট্যান্ট ব্যবহার করা হচ্ছে
echo Config::DB_HOST; // আউটপুট: localhost
echo Config::DB_USER; // আউটপুট: root

?>
কনস্ট্যান্টের বৈশিষ্ট্য:
কনস্ট্যান্টের নাম সাধারণত বড় হাতের অক্ষরে লেখা হয়।
কনস্ট্যান্টের মান একবার সেট করলে তা আর পরিবর্তন করা যায় না।
কনস্ট্যান্টকে $ সাইন ছাড়াই সরাসরি ব্যবহার করা হয় (যেমন: SITE_NAME বা Config::DB_HOST)।
কনস্ট্যান্ট গ্লোবাল স্কোপে থাকে, অর্থাৎ স্ক্রিপ্টের যেকোনো জায়গা থেকে এক্সেস করা যায়।



* extends  is keyword 
--------------------------
Laravel এবং PHP-তে "extends" হল একটি কীওয়ার্ড, যা অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP)-এ ইনহেরিটেন্সের ধারণাকে বোঝায়। যখন আপনি একটি ক্লাসকে "extends" করেন, তখন আপনি একটি নতুন ক্লাস তৈরি করেন যা অন্য একটি ক্লাসের প্রোপার্টি এবং মেথডগুলি ইনহেরিট করে। এর মাধ্যমে আপনি কোড পুনরায় লেখার প্রয়োজন ছাড়াই বিদ্যমান ফাংশনালিটিকে পুনরায় ব্যবহার করতে এবং বাড়িয়ে তুলতে পারেন।



In Laravel, the concept of "extends" refers to the use of inheritance in object-oriented programming (OOP). When you extend a class, you create a new class that inherits the properties and methods of another class. This allows you to reuse and extend functionality without duplicating code.

<?php

// একটি ক্লাস তৈরি করা হয়েছে Vehicle নামে
class Vehicle {
    public function startEngine() {
        return "Engine started";
    }
}

// Car ক্লাসটি Vehicle ক্লাস থেকে ইনহেরিট করেছে (extends ব্যবহার করে)
class Car extends Vehicle {
    public function drive() {
        return "Driving...";
    }
}

// Car ক্লাসের একটি ইনস্ট্যান্স তৈরি করা হয়েছে
$car = new Car();
echo $car->startEngine(); // আউটপুট: Engine started
echo $car->drive();       // আউটপুট: Driving...

?>



* implements
------------------------------------------
PHP-তে implements কীওয়ার্ডটি ইন্টারফেস (Interface) ব্যবহার করার জন্য ব্যবহৃত হয়। ইন্টারফেস হলো একটি ব্লুপ্রিন্ট যা কিছু মেথড ডিফাইন করে, তবে এই মেথডগুলোর কোনো বাস্তবায়ন (implementation) থাকে না। যখন কোনো ক্লাস একটি ইন্টারফেসকে implements করে, তখন সেই ক্লাসকে ইন্টারফেসে ডিফাইন করা সব মেথড বাস্তবায়ন করতে হয়।

<?php

// একটি ইন্টারফেস তৈরি করা হয়েছে
interface Animal {
    public function makeSound();
    public function move();
}

// Dog ক্লাসটি Animal ইন্টারফেসকে implements করেছে
class Dog implements Animal {
    public function makeSound() {
        return "Bark!";
    }

    public function move() {
        return "Run!";
    }
}

// Dog ক্লাসের একটি ইনস্ট্যান্স তৈরি করা হয়েছে
$dog = new Dog();
echo $dog->makeSound(); // আউটপুট: Bark!
echo $dog->move();      // আউটপুট: Run!

?>
মূল বিষয়গুলো:
ইন্টারফেস: এটি এমন একটি কনট্রাক্ট যা একটি ক্লাসকে মানতে হয়। এতে শুধু মেথডের নাম এবং সিগনেচার থাকে, কিন্তু কোনো কোড বা লজিক থাকে না।
implements: কোনো ক্লাস যখন একটি ইন্টারফেসকে implements করে, তখন সেই ক্লাসকে ইন্টারফেসে ডিফাইন করা সব মেথড বাস্তবায়ন করতে হয়।




* composer ki
--------------------
Composer PHP প্রজেক্টগুলোর জন্য একটি শক্তিশালী ডিপেনডেন্সি ম্যানেজার যা লাইব্রেরি এবং প্যাকেজ ম্যানেজমেন্ট, ভার্সন কন্ট্রোল, এবং অটোলোডিং সহজ করে তোলে। এটি ব্যবহারের মাধ্যমে কোড ম্যানেজমেন্ট আরও সহজ এবং দক্ষ হয়।

Composer-এর মূল বৈশিষ্ট্য:
প্যাকেজ ম্যানেজমেন্ট:

Composer আপনাকে বিভিন্ন প্যাকেজ বা লাইব্রেরি ইনস্টল করতে সহায়তা করে। প্যাকেজগুলি composer.json ফাইলের মাধ্যমে সংজ্ঞায়িত করা হয়।
অটোলোডিং:

Composer একটি অটোলোডার তৈরি করে যা ক্লাসগুলি স্বয়ংক্রিয়ভাবে লোড করে, ফলে আপনার প্রজেক্টের কোড আরও সংগঠিত ও সহজ হয়।
ভার্সন কন্ট্রোল:

Composer প্যাকেজগুলোর নির্দিষ্ট ভার্সন ম্যানেজ করতে পারে, যাতে আপনার প্রজেক্টে সঠিক ভার্সনের লাইব্রেরি ব্যবহৃত হয়।

Composer is used to managing its dependencies, which are noted in the composer.json file and placed in the source folder.




Instance ki ?
---------------------
Instance (ইনস্ট্যান্স) হলো একটি ক্লাসের বাস্তবায়ন বা উদাহরণ যা ক্লাসের কনস্ট্রাক্টর মেথডের মাধ্যমে তৈরি হয়। এটি ক্লাসের সমস্ত প্রোপার্টি এবং মেথড ধারণ করে এবং একটি নির্দিষ্ট অবজেক্ট হিসেবে কাজ করে।

ধরি, আপনি একটি Car ক্লাস তৈরি করেছেন। যখন আপনি সেই ক্লাসের একটি নতুন অবজেক্ট তৈরি করেন, তখন আপনি একটি ইনস্ট্যান্স তৈরি করছেন।

<?php

// একটি ক্লাস তৈরি করা হয়েছে
class Car {
    public $color;
    public $model;

    public function __construct($color, $model) {
        $this->color = $color;
        $this->model = $model;
    }

    public function startEngine() {
        return "Engine started";
    }
}

// Car ক্লাসের একটি ইনস্ট্যান্স তৈরি করা হয়েছে
$myCar = new Car("Red", "Toyota");

// ইনস্ট্যান্সের প্রোপার্টি এবং মেথড অ্যাক্সেস করা হচ্ছে
echo $myCar->color;          // আউটপুট: Red
echo $myCar->model;          // আউটপুট: Toyota
echo $myCar->startEngine();  // আউটপুট: Engine started

?>
মূল বিষয়গুলো:
ইনস্ট্যান্স: একটি ক্লাসের একটি কনক্রিট অবজেক্ট যা ক্লাসের প্রোপার্টি এবং মেথড ধারণ করে এবং ব্যবহৃত হয়।
কনস্ট্রাক্টর: একটি বিশেষ মেথড যা ক্লাসের নতুন ইনস্ট্যান্স তৈরি করার সময় রান হয় এবং ইনস্ট্যান্সের প্রোপার্টি ইনিশিয়ালাইজ করে।
সংক্ষেপে: ইনস্ট্যান্স হলো একটি ক্লাসের কনক্রিট অবজেক্ট যা ক্লাসের কনস্ট্রাক্টর দ্বারা তৈরি হয় এবং ক্লাসের প্রোপার্টি এবং মেথডের অ্যাক্সেস প্রদান করে।



Step 1: Define a Class

class Car {
    public $color;  // Property

    // Method
    public function setColor($color) {
        $this->color = $color;
    }

    // Method
    public function getColor() {
        return $this->color;
    }
}


Step 2: Create an Instance of the Class
To create an instance of a class, use the new keyword:

 $myCar = new Car();  // Creating an instance of the Car class


Class: A template for creating objects, defining their properties and methods.
Object: An instance of a class.
Instance: A specific realization of a class, created using the new keyword.
Properties and Methods: Attributes and behaviors defined within a class that can be used by its instances.


7. Objects, class ki kamne kaj kore
======================================================

সংক্ষেপে: ক্লাস হলো একটি টেমপ্লেট যা অবজেক্ট তৈরি করার জন্য ব্যবহৃত হয়, এবং অবজেক্ট হল ক্লাসের একটি বাস্তব উদাহরণ যা ক্লাসের প্রোপার্টি ও মেথড ব্যবহার করতে সক্ষম।

ক্লাস (Class):
ক্লাস হলো একটি ব্লুপ্রিন্ট বা টেমপ্লেট যা অবজেক্ট তৈরি করার জন্য ব্যবহৃত হয়। এটি প্রোপার্টি (ভেরিয়েবল) এবং মেথড (ফাংশন) ধারণ করে।

অবজেক্ট (Object):
অবজেক্ট হলো ক্লাসের একটি কনক্রিট উদাহরণ। এটি ক্লাসের প্রোপার্টি এবং মেথডগুলির বাস্তবায়ন করে এবং ক্লাসের ভিত্তিতে কাজ করে।

কিভাবে কাজ করে:
ক্লাস ডিফাইন করা:

ক্লাসটি সাধারণত প্রোপার্টি এবং মেথডের সংজ্ঞা দেয়। এটি একটি ধরনের ব্লুপ্রিন্ট যা বলে দেয় কোন ধরনের ডেটা এবং কার্যকারিতা অবজেক্টগুলির মধ্যে থাকবে।
ইনস্ট্যান্স তৈরি করা:

ক্লাসের একটি ইনস্ট্যান্স তৈরি করার মাধ্যমে একটি নতুন অবজেক্ট তৈরি করা হয়।
অবজেক্ট ব্যবহার করা:

অবজেক্ট তৈরি করার পরে, আমরা তার প্রোপার্টি এবং মেথড অ্যাক্সেস করতে পারি এবং ব্যবহার করতে পারি


PHP: Property - ক্লাস এর মেম্বার ভ্যারিয়েবল।





* static 
-------------
স্ট্যাটিক প্রোপার্টি এবং মেথড ব্যবহার করার জন্য, আপনাকে ক্লাসের অবজেক্ট তৈরি করার প্রয়োজন হয় না। আপনি সরাসরি ক্লাসের নাম ব্যবহার করে এগুলি অ্যাক্সেস করতে পারেন।

স্ট্যাটিক প্রোপার্টি
স্ট্যাটিক প্রোপার্টি: ক্লাসের একটি প্রোপার্টি যা ক্লাসের ইনস্ট্যান্স তৈরি না করেই অ্যাক্সেস করা যায়।
স্ট্যাটিক প্রোপার্টি ক্লাসের বাইরে থেকে :: অপারেটর ব্যবহার করে অ্যাক্সেস করতে হয়।
স্ট্যাটিক মেথড
স্ট্যাটিক মেথড: একটি মেথড যা ক্লাসের জন্য নির্ধারিত, কোন নির্দিষ্ট অবজেক্টের জন্য নয়।
স্ট্যাটিক মেথড ক্লাসের বাইরে থেকে :: অপারেটর ব্যবহার করে কল করা যায়।

<?php

// একটি ক্লাস তৈরি করা হয়েছে
class Dev {
    // স্ট্যাটিক প্রোপার্টি ডিফাইন করা হচ্ছে
    public static $age = 50;
    public static $name = "Obaydulla";

    // স্ট্যাটিক মেথড ডিফাইন করা হচ্ছে
    public static function name() {
        // ক্লাসের স্ট্যাটিক প্রোপার্টি অ্যাক্সেস করা হচ্ছে
        return "My name is " . self::$name;  // অথবা Dev::$name
    }
}

// ক্লাসের স্ট্যাটিক মেথড কল করা হচ্ছে
echo Dev::name(); // আউটপুট: My name is Obaydulla

?>
স্ট্যাটিক প্রোপার্টি এবং মেথড: ক্লাসের অবজেক্ট তৈরি না করে সরাসরি ক্লাসের নাম দিয়ে অ্যাক্সেস করা হয়।
স্কোপ রেজলিউশন অপারেটর (::): স্ট্যাটিক প্রোপার্টি ও মেথড অ্যাক্সেস করতে ব্যবহৃত হয়।





যে class er object না বানিয়ে যদি class এর বাইরে ব্যবহার করতে চাই  তাহলে static বানাতে হবে ।  static er property baire thake call kora jai na but method ke call kora jai....

static propery class ar baire  thake output dakha jai na.

static class scop rejation operator diye acces korte hoi.
In PHP, the double colon :: is called the scope resolution operator or Paamayim Nekudotayim. It is used to access static, constant, and overridden properties or methods of a class. It is also used to refer to parent classes.

Here's a breakdown of different uses of the :: operator:

1. Accessing Static Methods
Static methods are methods that belong to the class itself rather than to any specific object instance. You can call a static method using the :: operator.

class Dev {
    public static function name() {
        return "I am a static method";
    }
}

// Call the static method using the class name
echo Dev::name(); // Output: I am a static method

// Class ar vitor and bahire same waye to call korte hoi
class Dev {
    public static $age = 50;
    public static $name = "Obaydulla";

    public static function name () {
        return "My name is " . Dev::$name;
       return "My name is " . self::$name;  // we can user self that means our in our wan calss
    }

}
echo Dev::name();




10.  Namespace 
================================================================================
Namespace  -> নেমস্পেস মুলত ডিরেক্টরি বা ফাইলের লোকেশন ।
আমাদের প্রজেক্টে একই নামের কয়েকটা ক্লাস থাকতে পারে, একটা ক্লাসের সাথে আরেকোটা ক্লাস ফ্লাস না হয়ে  যায় এই জন্য Namespace ব্যাবহার করতে হয় । 

একাধিক function , class , interface , constant , trait , abstract  থাকতে পারে একটা  আরেকোটার সাথে ফ্লাস না হয় এই জন্য Namespace ব্যাবহার করতে হয় । 

laravel এর একটি ফাইল একটা নেমস্পেস হবে । বাকি গুলা use ব্যবহার করে নেমস্পেশ দেখাতে হয়  ।

আপানার লারাভেল প্যাকেজে বা অন্য যেকোনো পি এইচ পি ডেভেলপমেন্ট প্রোজেক্ট এ যদি একই নামে একাধিক function , class , interface , constant , trait , abstract থাকে তখন সমস্যা সৃষ্টি হবে । কোন টা ব্য্যবহার হচ্ছে সেটা ফিক্স করা সম্ভব না । এই সমস্যা সমাধানের জন্য নেমস্পেস ব্যবহার করা হয় ।

নেমস্পেসের মাধ্যমে ইমপোর্ট করা হয় use operator দিয়ে ।

একই নামের ২ টা ক্লাস থকলে Alias user করতে হবে  alias user kora hoi as diye।

use App\Controller\Student;
use AppSupport\Student\Student as MyStudent

$stu = new MyStudent;


Method chaining
-------------------------

 class Student {

    private $name = "Obaydulla";
    private $age = 5;
    private $dev = "Laravel Developer";


    /**
     * Set Student name
     */
     public function setName($name) {
        $this-> name = $name;
        return  $this;
     }

    /**
     * Set Student age
     */

     public function setAge($age) {
        $this-> age = $age;
        return  $this;
     }

     
    /**
     * Set Student name
     */
    public function setDev($dev) {
        $this-> dev = $dev;
        return  $this;
     }

    /**
     * info methods
     */
    public function info() {
        return "My name is ". $this->name ." & I am ". $this->age ." years old and I am a " . $this->dev ;
    }
 }

 $student = new Student;

 echo $student -> setDev("Java Developer") -> setName("Refat")->setAge(150)->info();

15
===================

Public: এটা সবার জন্য খোলা। তুমি যেকোনো জায়গা থেকে এটি ব্যবহার করতে পারো।

Private: এটা শুধু সেই ক্লাসের ভেতরে থাকা জন্য। যদি বাইরে থেকে ব্যবহার করতে চাও, তাহলে ক্লাসের ভেতরের অন্য কোনো মেথডের মাধ্যমে যেতে হবে।

Protected: এটা একটু সুরক্ষিত। শুধু সেই ক্লাস এবং যেসব ক্লাস এই ক্লাসকে "extends" করেছে, তারা এটা ব্যবহার করতে পারবে।






Satt Academy
====================================================================

পিএইচপি OOP
OOP এর পূর্ণরূপ হলঃ Object-Oriented Programming। OOP তে সবকিছুই অবজেক্ট। যেমন- আপনি আমাদের এই বিশ্বকে নিয়ে কল্পনা করতে পারেন যা চাঁদ, সূর্য, পৃথিবী ইত্যাদি অবজেক্ট নিয়ে গঠিত।

একইভাবে, আপনি একটি গাড়ি কল্পনা করতে পারেন যা চাকা, গিয়ার, ইঞ্জিন ইত্যাদি অবজেক্ট নিয়ে গঠিত।

অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং এর ধারণাও অনেকটা পথিবী এবং গাড়ির মতই। এটি সবকিছুকেই অবজেক্ট হিসাবে বিবেচনা করে। আপনি এই অবজেক্ট সমূহ ব্যবহার করে বিভিন্ন অ্যাপ্লিকেশন তৈরি করতে পারেন।

পিএইচপির ভার্সন-৪ এ অবজেক্ট অরিয়েন্টেড বৈশিষ্ট্য না থাকলেও ভার্সন-৫ এ অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং কৌশল এর সম্পূর্ণ বৈশিষ্ট্য যুক্ত হয়েছে। পিএইচপিতে অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং ব্যবহার করে অনেক বৃহৎ ও জটিল ওয়েব অ্যাপ্লিকেশন তৈরি করা সম্ভব।

পিএইচপি OOP উদাহরণ
kt_satt_skill_example_id=564

অবজেক্ট অরিয়েন্টেডের গুরুত্বপূর্ণ বিষয় বস্তু
আমরা আমাদের টিউটোরিয়ালে অবজেক্ট অরিয়েন্টেডের নিম্নোক্ত বিষয় সমূহ নিয়ে আলোচনা করবোঃ

PHP: Class - প্রোপার্টি(মেম্বার ভ্যারিয়েবল) এবং মেম্বার ফাংশন(মেথড) এর সমন্বয়ে অবজেক্ট তৈরির জন্য ক্লাস হলো সম্প্রসারণযোগ্য প্রোগ্রামিং কোড এর একটি নীল নকশা(templete)।
PHP: Object - অবজেক্ট হলো ক্লাস এর একটি বিশেষ নিদর্শন(instance) যা ভ্যারিয়েবল, ফাংশন এবং ডেটা স্ট্রাকচার এর সমন্বয়ে গঠিত হতে পারে।
PHP: Method - ক্লাস এর মেম্বার ফাংশনসমূহকে OOP তে মেথড বলা হয়। মেথড হলো অবজেক্ট-ক্লাস এর সাথে সম্পর্কিত একটি প্রক্রিয়া। একটি অবজেক্ট তথ্য এবং তথ্য প্রক্রিয়া এর সমন্বয়ে গঠিত হয়। "তথ্যকে" অবজেক্ট এর বৈশিষ্ট্য(property) এবং "তথ্য প্রক্রিয়াকে" মেথড এর মাধ্যমে প্রকাশ করা হয়। মেথড বাইরের অবজেক্ট এর সাথেও সম্পর্ক তৈরি করতে পারে।
PHP: Property - ক্লাস এর মেম্বার ভ্যারিয়েবল।
PHP: Encapsulation - প্রোপার্টি এবং মেথডসমূহ একত্রিত করে অবজেক্ট তৈরির একটি কৌশল।
PHP: Inheritance - কোড ডুপ্লিকেশন কমানোর জন্য প্যারেন্ট ক্লাস এর প্রোপার্টি এবং মেথড চাইল্ড ক্লাসও ব্যবহার করতে পারে।
PHP: Parent class - অন্য সকল ক্লাস এই ক্লাস কে ইনহেরিট করে। প্যারেন্ট ক্লাসের অপর নাম সুপার ক্লাস বা বেইজ ক্লাস।
PHP: Child Class - এই ক্লাস অন্য সকল ক্লাসকে ইনহেরিট করে। এই ক্লাসের অপর নাম সাবক্লাস বা ডিরাইভ ক্লাস।
PHP: Polymorphism - বিভিন্ন ক্লাসের যেসব মেথডসমূহ একই কাজে ব্যবহৃত হয় তাদের নামকরণ একই হওয়া।
PHP: Overloading and Overriding - অভারলোডিং তখনই ঘটে যখন একই ক্লাসে দুই বা তার অধিক মেথড এর নাম একই কিন্তু প্যারামিটার ভিন্ন হয়। Overriding এর অর্থ হলো দুটি মেথডের নাম এবং প্যারামিটার(method signature) একই। একটি মেথড থাকে প্যারেন্ট ক্লাসে এবং অপরটি থাকে চাইল্ড ক্লাসে।
PHP: abstract class and method - এটি একটি অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং পদ্ধতি। এই পদ্ধতিতে একজন প্রোগ্রামার প্রাসঙ্গিক তথ্য ছাড়া সকল কিছুই লুকিয়ে রাখতে পারে। যেমন- প্যারেন্ট ক্লাসের কিছু নির্দিষ্ট মেথডে চাইল্ড ক্লাস এক্সেস নিতে পারবে এমন অঙ্গীকার করার জন্য আমরা abstract class ব্যবহার করি। কিন্তু আমরা এই অঙ্গীকার করি না যে, মেথডের মধ্যে কি ধরণের কোড থাকবে।
PHP: Interface - প্যারেন্ট ক্লাস চাইল্ড ক্লাসের সাথে এই অঙ্গীকার করে যে, মেথড বাস্তবায়নের জন্য চাইল্ড ক্লাস প্যারেন্ট ক্লাস এর abstract মেথডসমূহ এক্সেস করতে পারবে।
PHP: public, private এবং protected প্রোপার্টি - প্রোপার্টিসমূহ public, private অথবা protected হতে পারে। public অর্থ প্রোপার্টিসমূহকে যেকোন স্থান থেকে এক্সেস করা যাবে, private অর্থ শুধুমাত্র সংশ্লিষ্ট ক্লাস থেকে এক্সেস করা যাবে এবং protected অর্থ হলো সংশ্লিষ্ট ক্লাস এবং এর চাইল্ড ক্লাস থেকেও এক্সেস করা যাবে।
PHP: Public, Private এবং Protected মেথড - মেথডসমূহ public, private অথবা protected হতে পারে। public অর্থ মেথডসমূহকে যেকোন স্থান থেকে এক্সেস করা যাবে, private অর্থ শুধুমাত্র সংশ্লিষ্ট ক্লাস থেকে এক্সেস করা যাবে এবং protected অর্থ হলো সংশ্লিষ্ট ক্লাস এবং এর চাইল্ড ক্লাস থেকেও এক্সেস করা যাবে।
PHP: Constructor - পিএইচপির বিশেষ ধরণের বিল্ট-ইন মেথড। অবজেক্ট তৈরির সময় প্রোপার্টির ভ্যালু এসাইনে সম্মতি দেয়। অবজেক্ট তৈরি হলে এই মেথডটি স্বয়ংক্রিয়ভাবেই সম্পাদিত হয়। দুটি আন্ডারস্কোর(__) দিয়ে construct মেথড শুরু হয়।
PHP: Destructor - Constructor এর বিপরীত। অবজেক্ট ধ্বংশ হয়ে গেলে এটি স্বয়ংক্রিয়ভাবেই কল হয়।
PHP: Type Hinting - ফাংশন ডিক্লেয়ারেশনের সময় আরগুমেন্ট এর জন্য প্রত্যাশিত ডেটা টাইপ( (arrays, objects, interface ইত্যাদি) নির্ধারণ করে দেওয়া হয়।
PHP: Static property এবং method - নতুন অবজেক্ট তৈরি করা ছাড়াই ক্লাস এর প্রোপার্টি এবং মেথডকে এক্সেস করা যায়।
PHP: Object Cloning - অবজেক্ট এর একটি কপি তৈরি করতে ক্লোনিং ব্যবহৃত হয়।
PHP : spl_autoload_register() - প্রয়োজনীয় সকল ক্লাসকে সংশ্লিষ্ট ফাইলে স্বয়ংক্রিয়ভাবে লোড করে।
PHP: scope Resolution Operator(::) - একটি class এর static, constant এবং overridden প্রোপার্টি অথবা মেথডকে এক্সেস করতে পিএইচপি scope Resolution Operator(::) ব্যবহৃত হয়।
PHP: Magic Method __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state() এবং __clone() ফাংশনকে পিএইচপি ম্যাজিক মেথড বলা হয়।

#### সহজভাবে:
- **Service Provider**: আপনার অ্যাপ্লিকেশনের বিভিন্ন সার্ভিস (যেমন ডাটাবেজ, ইমেইল ইত্যাদি) রেজিস্টার ও কনফিগার করার জন্য ব্যবহৃত হয়।

- **Service Container**: আপনার ক্লাসগুলোতে প্রয়োজনীয় ডিপেনডেন্সি (অন্য ক্লাস বা সার্ভিস) সরবরাহ করার জন্য ব্যবহৃত হয়।
Laravel এ সবকিছুই মূলত `Service Provider` এর মাধ্যমে রেজিস্টার করা হয় এবং `Service Container` এর মাধ্যমে পরিচালিত হয়।

Service Container হচ্ছে একটি কন্টেইনার যে কিনা ক্লাস গুলো কে তার কাছে hold করে যাতে করে পরবর্তিতে আমরা আমাদের প্রয়োজন মতো ক্লাসের অবজেক্ট গুলো কে ব্যবহার করতে পারি।
Service provider হচ্ছে Application এর central place, যেখানে core service গুলো bootstrapping হয়।















