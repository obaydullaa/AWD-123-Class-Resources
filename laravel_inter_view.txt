1. Mvc
2. Relationship
3. Eloquent query method
 Skip,  take, orderby,  where,  jason contens
4. Filtaring, searching, 
5. Php oop concept
6. function, static Trait,  interface, constant ,  abstract , extends , implements, composer ki
7. Objects, class ki kamne kaj kore
8. Design
9. Interview questions from google
 
10.  Namespace -> নেমস্পেস মুলত ডিরেক্টরি বা ফাইলের লোকেশন ।
*
11. What is Composer ?

12. Method chaining

13. Type hint  = func student(string $name) {}

14. Facade ki ?

15. Public:  Private: Protected

$student->setName('obaydulla') =>  The -> symbol itself is called the object operator in PHP.
The :: symbol in PHP is called the scope resolution operator or sometimes the
class MyClass {
    const MY_CONSTANT = 'Hello';

    public static function myStaticMethod() {
        return 'This is a static method';
    }
}      

// Accessing a constant 
echo MyClass::MY_CONSTANT;  // Outputs:  Hello

// Accessing a static method
echo MyClass::myStaticMethod(); // Outputs: This is a static method

In this example, :: is used to access the constant MY_CONSTANT and the static method myStaticMethod within MyClass.

1. MVC
=================================================================================

MVC pattern মানে Model–view–controller

Model–view–controller হল একটি সফটওয়্যার ডেভেলপমেন্ট একটি জনপ্রিয় আদর্শ বা নমুনা ।
এই প্যাটার্নটি ব্যাবহার করা হয় সফটওয়্যারটি কে তিনটি ভাগে ভাগ করার জন্য।

Model: মডেলের কাজ হল ডাটাবেসের সাথে যোগাযোগ করা, যেমন কিছু ডেটা যোগ করা বা কিছু ডেটা মুছে ফেলা ডাটাবেস থেকে ।

View: view হল আমরা ওয়েব পেজে যা দেখি, এটি আমাদের ভিজ্যুয়াল অংশ। যেমন html css ।

Controller: Controller সবকিছু নিয়ন্ত্রণ করে, কি নিয়ন্ত্রণ করে ? এটি মডেল কে ব্যাবহার করে ডাটাবেস থেকে ডাটা নিয়ে আসে এবং view এর মাঝে ডাটা দিয়ে HTML response তৈরি করে এবং অবশেষে HTML response কে ব্রাউজার এ পাঠায় ।


২য় ভাগঃ লারাভেল এ MVC pattern এর ব্যাবহার

যখন আমরা লারাভেল অ্যাপ্লিকেশনে একটি request পাঠাই, তখন এই request (অনুরোধ ) টি প্রথমে রুট ফাইলে (web.php) যায় এবং রুট ফাইলটি অ্যাপোরিয়েট কন্ট্রোলারের কাছে এই request (অনুরোধ ) টি পাঠায়। controller তারপর model কে ব্যবহৃত করে ডেটাবেস থেকে ডেটা আনে এবং view থেকে HTML, CSS নিয়ে আসে । তারপর ডেটা , html, css দিয়ে controller একটি response প্রস্তুত করে ব্রাউজারে ফেরত পাঠানোর জন্য । যখন ব্রাউজার রিকোয়েস্টের পরে রিসপন্স ফিরে পায় তখন HTML পেজটি সঠিকভাবে প্রদর্শন করে এবং আমরা ওয়েব পেজ দেখতে পাই।

2. Relationship
========================================================================


1. One to One
------------------
Facebook Profile Picture


ধরো তুমি Facebook ব্যবহার করো। প্রত্যেক Facebook ব্যবহারকারীর একটি করে প্রোফাইল ছবি থাকে। এই প্রোফাইল ছবির সাথে তোমার বিশেষ সম্পর্ক থাকে, যেটা শুধুমাত্র তোমার। আর কেউ তোমার প্রোফাইল ছবির মালিক হতে পারে না। Laravel-এ এই সম্পর্ককে আমরা "One to One" সম্পর্ক বলি।

// User মডেল
class User extends Model {
    public function profilePicture() {
        return $this->hasOne(ProfilePicture::class);
    }
}

// ProfilePicture মডেল
class ProfilePicture extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}

এখানে, User মডেলে আমরা hasOne ব্যবহার করে দেখাচ্ছি যে, প্রত্যেক ব্যবহারকারীর একটি করে প্রোফাইল ছবি থাকতে পারে। আর ProfilePicture মডেলে belongsTo ব্যবহার করে দেখানো হয়েছে যে, প্রোফাইল ছবিটি একটি নির্দিষ্ট ব্যবহারকারীর সাথে সম্পর্কিত।


2. One to Many
--------------------------
 Facebook Posts


"One to Many" সম্পর্কের মূল কথা হলো, একটি একক মডেল (যেমন: User) অন্য একটি মডেলের (যেমন: Post) একাধিক ইনস্ট্যান্সের সাথে সম্পর্কিত হতে পারে। অর্থাৎ, একজন User অনেকগুলো Post তৈরি করতে পারে, কিন্তু প্রতিটি Post এর সাথে শুধুমাত্র একটি User যুক্ত থাকে।

উদাহরণ: Facebook-এ একজন ব্যবহারকারী (User) একাধিক পোস্ট (Post) করতে পারে। যেমন, তুমি প্রতিদিন অনেকগুলো পোস্ট করতে পারো, কিন্তু প্রতিটি পোস্টের মালিক তুমি একাই।

// User মডেল
class User extends Model {
    public function posts() {
        return $this->hasMany(Post::class);
    }
}

// Post মডেল
class Post extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}


hasMany: User মডেলে hasMany ফাংশনটি ব্যবহার করে জানাচ্ছে যে একজন User অনেকগুলো Post তৈরি করতে পারে।
belongsTo: Post মডেলে belongsTo ফাংশনটি ব্যবহার করে জানাচ্ছে যে প্রতিটি Post এর সাথে একটি নির্দিষ্ট User যুক্ত থাকে।




3. Many to One
---------------------------
 Facebook Posts

ধরো, Facebook-এ তুমি একটি পোস্ট করেছো। এখন অনেকেই তোমার পোস্টে মন্তব্য (Comment) করতে পারে। প্রতিটি মন্তব্য একাধিক ব্যবহারকারীর (User) হতে পারে, কিন্তু একটি মন্তব্যের সাথে শুধুমাত্র একটি পোস্ট যুক্ত থাকবে। অর্থাৎ, একাধিক মন্তব্য একটি নির্দিষ্ট পোস্টের অধীনে থাকবে।

এটা Laravel-এর "Many to One" সম্পর্ক বোঝায়।

// Post মডেল
class Post extends Model {
    public function comments() {
        return $this->hasMany(Comment::class);
    }
}

// Comment মডেল
class Comment extends Model {
    public function post() {
        return $this->belongsTo(Post::class);
    }
}

এখানে, Post মডেলে hasMany ফাংশন ব্যবহার করে দেখানো হয়েছে যে, একটি পোস্টের অধীনে অনেকগুলো মন্তব্য থাকতে পারে। অন্যদিকে, Comment মডেলে belongsTo ফাংশন ব্যবহার করে দেখানো হয়েছে যে, প্রতিটি মন্তব্য শুধুমাত্র একটি পোস্টের সাথে সম্পর্কিত।


4. Many to Many
-----------------------
Facebook Groups & Users

Many to Many সম্পর্ক হলো, দুটি মডেল একে অপরের সাথে একাধিক ইনস্ট্যান্সের মাধ্যমে সম্পর্কিত হতে পারে। অর্থাৎ, একটি মডেল অনেকগুলোর সাথে সম্পর্কিত হতে পারে, এবং সেই মডেলগুলোও অনেকগুলোর সাথে সম্পর্কিত হতে পারে।

উদাহরণ: Facebook Groups & Users
ধরো, Facebook-এ অনেকগুলো গ্রুপ (Group) আছে, এবং একজন ব্যবহারকারী (User) একাধিক গ্রুপে যোগ দিতে পারে। আবার, একটি গ্রুপে অনেকগুলো ব্যবহারকারী থাকতে পারে। এখানে User এবং Group এর মধ্যে "Many to Many" সম্পর্ক থাকে।
}

// User মডেল
class User extends Model {
    public function groups() {
        return $this->belongsToMany(Group::class);
    }
}

// Group মডেল
class Group extends Model {
    public function users() {
        return $this->belongsToMany(User::class);
    }
}

Many to Many সম্পর্ক হলো, একটি মডেল (যেমন User) অনেকগুলোর (যেমন Group) সাথে সম্পর্কিত হতে পারে, এবং সেই মডেলগুলোও (যেমন Group) অনেকগুলোর (যেমন User) সাথে সম্পর্কিত হতে পারে।
এখানে Laravel-এর belongsToMany ফাংশন ব্যবহার করা হয় এই সম্পর্কটি তৈরি করার জন্য।




5. Has Many Through
-------------------------------
 Countries -> Users -> Posts

Imagine your grandparents have many grandchildren through their children (your parents). In Laravel, this is called a "Has Many Through" relationship. It means you can find a connection through another person.


ধরো, তুমি একটি ওয়েবসাইট তৈরি করছো যেখানে ব্যবহারকারীরা বিভিন্ন দেশ থেকে আসে এবং পোস্ট করে। এখানে প্রতিটি দেশ (Country) অনেকগুলো ব্যবহারকারী (User) আছে, এবং প্রতিটি ব্যবহারকারী অনেকগুলো পোস্ট (Post) করতে পারে। এখানে "Has Many Through" সম্পর্ক ব্যবহার করে আমরা Country মডেল থেকে সরাসরি Post মডেলে সম্পর্ক তৈরি করতে পারি।
এটা এক ধরনের শর্টকাট এ রিলেশন করার মতো এবং অনেক গুলো রিলেশন একবারে নিক্ষেপ করা । আপনি মানব বন্ধন দেখেছেন , সেখানে এক জনের হাতের সাথে অন্য আরেক জনের হাত যুক্ত হয়ে বিশাল লাইন হয় । প্রথম আর শেষের মানুষ এর সংযোগ আছে না ?

প্রথম আর শেষের মানুষের হাত সংযুক্ত না , তারপর ও কিন্তু যুক্ত আছে । কেমনে যুক্ত , আক জনের সাথে অন্য জনের হাত সংযুক্ত হয়ে সব শেষের মানুষ সংযোগ হয়েছে ।


// Country মডেল
class Country extends Model {
    public function posts() {
        return $this->hasManyThrough(Post::class, User::class);
    }
}

// User মডেল
class User extends Model {
    public function posts() {
        return $this->hasMany(Post::class);
    }
}

// Post মডেল
class Post extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}



countries
    id - integer
    name - string
users
    id - integer
    country_id - integer
    name - string
posts
    id - integer
    user_id - integer
    title - string
Has Many Through সম্পর্ক হলো, একটি মডেল (যেমন Country) একটি মধ্যস্থ মডেলের (যেমন User) মাধ্যমে তৃতীয় একটি মডেলের (যেমন Post) সাথে সম্পর্কিত।
এখানে Country মডেল User মডেলের মাধ্যমে Post মডেলের সাথে সম্পর্কিত, যার মাধ্যমে আমরা একটি দেশ থেকে সরাসরি তার সমস্ত পোস্ট দেখতে পারি।
এটা হলো কিভাবে একটি মডেল অন্য একটি মডেলের মাধ্যমে তৃতীয় একটি মডেলের সাথে সম্পর্কিত হতে পারে তার উদাহরণ।











6. Polymorphic Relations
--------------------------------
হ্যাঁ, এটি পলিমরফিজমের একটি উদাহরণ। পলিমরফিজম (Polymorphism) হলো প্রোগ্রামিংয়ের একটি ধারণা, যেখানে একই নামের মেথড বা ফাংশন বিভিন্ন ধরণের কাজ করতে পারে। সহজভাবে বললে, পলিমরফিজমের মাধ্যমে আমরা একই মেথডের মাধ্যমে ভিন্ন ভিন্ন ধরণের অবজেক্টকে আলাদা ভাবে ব্যবহার করতে পারি।

<?php
class ParentClass {
    public function makeCake() {
        echo "Making a simple cake.";
    }
}

class ChildClass extends ParentClass {
    public function makeCake() {
        echo "Making a cake with chocolate!";
    }
}

$cake1 = new ParentClass();
$cake2 = new ChildClass();

$cake1->makeCake(); // এটা প্রিন্ট করবে: "Making a simple cake."
$cake2->makeCake(); // এটা প্রিন্ট করবে: "Making a cake with chocolate!"
?>



আপনি অনেক সাইটে দেখবেন পোস্ট এবং ভিডিও পোস্ট এর জন্য আলাদা আলাদা সিঙ্গেল পেজ ব্যবহার করা হয় । পোস্ট এবং ভিডিও পোস্ট দুই পেজে আপনি কমেন্ট করতে পারেন । আচ্ছা দুইটা আলাদা পেজের জন্য কি দুটা আলাদা কমেন্ট টেবিল বানাবেন ?? যেমন post_comments_table , video_post_comments_table

পলিমোরফিক রিলেশন দিয়ে শুধুমাত্র একটা টেবিল দিয়ে দুই পেজেই কমেন্ট কন্ট্রোল করতে পারবেন । আচ্ছা দেখুন কিভাবে পলিমোরফিক রিলেশন সেট করবেন – posts videos comments আপনার তিনটা টেবিল । comments টেবিল পলিমোরফিক বা বহুরূপী হিসেবে সেট করবেন ।

posts
    id - integer
    title - string
    body - text

videos
    id - integer
    title - string
    url - string

comments
    id - integer
    body - text
    commentable_id - integer
    commentable_type - string

commentable_id এখানে সেভ হবে posts/videos id এবং commentable_type এ থাকবে টাইপ post অথবা video ।

এখন Model কেমন হবে দেখুন

<?php
namespace App;
use Illuminate\Database\Eloquent\Model;
class Comment extends Model
{
    /**
     * Get all of the owning commentable models.
     */
    public function commentable()
    {
        return $this->morphTo();
    }
}
class Post extends Model
{
    /**
     * Get all of the post's comments.
     */
    public function comments()
    {
        return $this->morphMany('App\Comment', 'commentable');
    }
}
class Video extends Model
{
    /**
     * Get all of the video's comments.
     */
    public function comments()
    {
        return $this->morphMany('App\Comment', 'commentable');
    }
}




3. Eloquent query method
================================================================================
Eloquent is an object-relational mapper (ORM)
Eloquent models represent database tables.
Models can be used to perform operations on data
Eloquent also supports relationships between models
It provides layer between application and databas

Naming Convention
----------------------------
Table name: brands Model name: Brand
Table name: product_details Model name: ProductDetails

Skip,  take, orderby,  where jason contens

**Skip and take method : skip method diye koita data skip korbo seta likte hobe r take method diye koita data nibo seta likte hobe .
example: 

student::skip(2)->take(4)->get();

 ** orderby :
-------------

asc (Ascending):
---------------------------
Numerical Order: From the smallest number to the largest (e.g., 1, 2, 3, ..., 10).
Alphabetical Order: From A to Z.
Date Order: From the earliest date to the latest date.

desc (Descending):
-------------------------
Numerical Order: From the largest number to the smallest (e.g., 10, 9, 8, ..., 1).
Alphabetical Order: From Z to A.
Date Order: From the latest date to the earliest date.

$users = User::orderBy('name', 'asc')->get();
	This query retrieves users ordered by their names in ascending alphabetical order (A to Z).

$products = Product::orderBy('price', 'asc')->get();
	This query retrieves products ordered by their price in ascending order (cheapest to most expensive).

$users = User::orderBy('created_at', 'desc')->get();
	This query retrieves users ordered by their creation date in descending order (newest to oldest).



** where 
-------------------
$animalBooks = AnimalBook::where('pages', '>', 100)->get();

$animalBooksByJohnDoe = AnimalBook::where('author', 'John Doe')
                                   ->where('pages', '>', 100)
                                   ->get();

$userId = 1; // Assuming 1 is the ID of the specific user
$userPosts = Post::where('user_id', $userId)->get();
class PostController extends Controller
{
    public function index()
    {
        $userId = 1; // Assuming 1 is the ID of the specific user
        $filteredPosts = Post::where('published_at', '>', '2023-01-01')
                             ->where('user_id', $userId)
                             ->whereHas('comments', function ($query) {
                                 $query->havingRaw('COUNT(*) > 10');
                             })
                             ->get();
        
        return view('posts.index', ['posts' => $filteredPosts]);
    }
}

<?php

// 1. Retrieve All Records
// Retrieves all records from the 'users' table.
$users = User::all();

// 2. Find a Record by Primary Key
// Retrieves the record with id 1 from the 'users' table.
$user = User::find(1);

// 3. Where Clauses
// Retrieves all users where the 'status' column is 'active'.
$users = User::where('status', 'active')->get();

// 4. Retrieve Single Record
// Retrieves the first user with the email 'example@example.com'.
$user = User::where('email', 'example@example.com')->first();

// 5. Pluck Columns
// Retrieves all user names from the 'users' table.
$userNames = User::pluck('name');

// 6. Order By
// Retrieves all users ordered by their 'name' in ascending order.
$users = User::orderBy('name', 'asc')->get();

// 7. Limit and Offset
// Retrieves 10 users, starting from the 6th user (offset 5).
$users = User::limit(10)->offset(5)->get();

// 8. Pagination
// Retrieves 15 users per page with pagination links.
$users = User::paginate(15);

// 9. Join Tables
// Retrieves users along with their post titles by joining the 'posts' table.
$users = User::join('posts', 'users.id', '=', 'posts.user_id')
             ->select('users.*', 'posts.title')
             ->get();

// 10. Eager Loading
// Retrieves all users along with their associated posts in a single query.
$users = User::with('posts')->get();

// 11. Has Many Through
// Assuming you have a 'Country' model with a 'posts' relationship,
// retrieves all posts for the country with id 1.
$posts = Country::find(1)->posts;

// 12. Combining Methods
// Retrieves the first 10 active users ordered by name in ascending order.
$users = User::where('status', 'active')
             ->orderBy('name', 'asc')
             ->limit(10)
             ->get();

?>




**  jason contens
-----------------------
<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Models\Profile;

// 1. JSON রেসপন্স
// এই রুটটি একটি JSON রেসপন্স প্রদান করে যা ব্যবহারকারীর বিস্তারিত তথ্য ধারণ করে।
Route::get('/json-example', function () {
    // JSON হিসেবে ফেরত দেওয়ার জন্য ডেটা নির্ধারণ করা হয়েছে
    $data = [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'age' => 30
    ];

    // JSON রেসপন্স হিসেবে ডেটা ফেরত দেওয়া হয়েছে
    return response()->json($data);
});

// 2. JSON ডেটা গ্রহণ
// এই রুটটি একটি POST রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করে এবং তা ফেরত দেয়।
Route::post('/json-receive', function (Request $request) {
    // রিকোয়েস্ট থেকে সমস্ত JSON ডেটা গ্রহণ করা হয়েছে
    $data = $request->json()->all();

    // প্রাপ্ত ডেটা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'received_data' => $data
    ]);
});

// 3. JSON রিকোয়েস্ট থেকে নির্দিষ্ট মান নেওয়া
// এই রুটটি POST রিকোয়েস্ট থেকে JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করে।
Route::post('/json-value', function (Request $request) {
    // JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করা হয়েছে
    $name = $request->input('name');
    $email = $request->input('email');

    // প্রাপ্ত মান JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'name' => $name,
        'email' => $email
    ]);
});

// 4. JSON ডেটা ডেটাবেসে সেভ করা
// এই রুটটি JSON ডেটা ডেটাবেসে 'preferences' কলামে সংরক্ষণ করে।
Route::post('/save-preferences', function (Request $request) {
    // রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করা হয়েছে
    $preferences = $request->json()->get('preferences');

    // নতুন একটি Profile ইনস্ট্যান্স তৈরি করা হয়েছে এবং JSON ডেটা সেভ করা হয়েছে
    $profile = new Profile();
    $profile->preferences = $preferences;
    $profile->save();

    // সফলতার বার্তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে
    return response()->json([
        'message' => 'Preferences saved successfully!'
    ]);
});

// 'profiles' টেবিল তৈরি করার জন্য মাইগ্রেশন
// JSON কলামসহ ডেটাবেস টেবিল তৈরি করার জন্য মাইগ্রেশন উদাহরণ
Schema::create('profiles', function (Blueprint $table) {
    $table->id(); // অটো-ইনক্রিমেন্ট আইডি
    $table->json('preferences'); // JSON কলাম যা JSON ডেটা সংরক্ষণ করবে
    $table->timestamps(); // তৈরি হওয়া এবং আপডেট হওয়ার সময়
});
?>

JSON রেসপন্স
------------
Route::get('/json-example', function () {
    $data = [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'age' => 30
    ];

    return response()->json($data);
});

JSON ডেটা গ্রহণ
---------------------
Route::post('/json-receive', function (Request $request) {
    $data = $request->json()->all();

    return response()->json([
        'received_data' => $data
    ]);
});

উদ্দেশ্য: POST রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করা এবং তা ফেরত দেওয়া।
কিভাবে কাজ করে: $request->json()->all() মেথড ব্যবহার করে সমস্ত JSON ডেটা গ্রহণ করা হয়েছে এবং তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।


SON রিকোয়েস্ট থেকে নির্দিষ্ট মান নেওয়া
-------------------------------------
Route::post('/json-value', function (Request $request) {
    $name = $request->input('name');
    $email = $request->input('email');

    return response()->json([
        'name' => $name,
        'email' => $email
    ]);
});

উদ্দেশ্য: POST রিকোয়েস্ট থেকে JSON ডেটা থেকে নির্দিষ্ট মান গ্রহণ করা।
কিভাবে কাজ করে: $request->input('name') এবং $request->input('email') মেথড ব্যবহার করে নির্দিষ্ট মান গ্রহণ করা হয়েছে এবং তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।


JSON ডেটা ডেটাবেসে সেভ করা
Route::post('/save-preferences', function (Request $request) {
    $preferences = $request->json()->get('preferences');

    $profile = new Profile();
    $profile->preferences = $preferences;
    $profile->save();

    return response()->json([
        'message' => 'Preferences saved successfully!'
    ]);
});
উদ্দেশ্য: JSON ডেটা ডেটাবেসে সংরক্ষণ করা।
কিভাবে কাজ করে: রিকোয়েস্ট থেকে JSON ডেটা গ্রহণ করে preferences কলামে সেভ করা হয়েছে এবং সফলতার বার্তা JSON রেসপন্স হিসেবে ফেরত দেওয়া হয়েছে।

মাইগ্রেশন
----------------
Schema::create('profiles', function (Blueprint $table) {
    $table->id(); // অটো-ইনক্রিমেন্ট আইডি
    $table->json('preferences'); // JSON কলাম
    $table->timestamps(); // তৈরি হওয়া এবং আপডেট হওয়ার সময়
});

উদ্দেশ্য: JSON কলামসহ ডেটাবেস টেবিল তৈরি করা।
কিভাবে কাজ করে: profiles টেবিল তৈরি করার জন্য মাইগ্রেশন ব্যবহার করা হয়েছে, যেখানে preferences কলামটি JSON ডেটা সংরক্ষণের জন্য ব্যবহৃত হবে।








6. function, static, Trait, abstract, interface, constant , , extends , implements
==================================================================
Function
---------------

What is a PHP Function?
A function in PHP is a block of code that can be executed whenever it is called within a script. It can take input in the form of parameters and can return a value after performing its task.

PHP ফাংশন হল কোডের একটি ব্লক যা নির্দিষ্ট একটি কাজ সম্পন্ন করে। ফাংশন ব্যবহার করলে একই কোড বারবার লেখার দরকার হয় না। এখানে PHP ফাংশনের একটি উদাহরণ দেওয়া হলো:

<?php

// ফাংশন ডিফাইন করা হয়েছে
function greet($name) {
    // এখানে $name প্যারামিটার হিসেবে নেওয়া হয়েছে এবং একটি শুভেচ্ছা বার্তা প্রদর্শন করা হয়েছে
    return "Hello, " . $name . "!";
}

// ফাংশন কল করা হচ্ছে এবং "John" নাম পাঠানো হচ্ছে
echo greet("John"); // আউটপুট: Hello, John!

// ফাংশন আবার কল করা হচ্ছে এবং "Alice" নাম পাঠানো হচ্ছে
echo greet("Alice"); // আউটপুট: Hello, Alice!

?>

ফাংশন ডিফাইন করা: greet() নামে একটি ফাংশন তৈরি করা হয়েছে যা $name নামে একটি প্যারামিটার গ্রহণ করে।
ফাংশন কাজ: ফাংশনটি $name প্যারামিটারকে "Hello, " স্ট্রিং-এর সাথে যুক্ত করে এবং একটি শুভেচ্ছা বার্তা রিটার্ন করে।
ফাংশন কল করা: greet("John") এবং greet("Alice") কল করা হলে, ফাংশনটি সংশ্লিষ্ট নামের জন্য শুভেচ্ছা বার্তা প্রদান করবে।
এই ফাংশনটি একাধিক বার ব্যবহার করা যেতে পারে বিভিন্ন নামের জন্য শুভেচ্ছা বার্তা প্রদানের উদ্দেশ্যে।

Anonymous Function
-----------------------------------
PHP-তে অ্যানোনিমাস ফাংশন হলো একটি ফাংশন যার কোনো নাম নেই। এই ধরনের ফাংশনকে ক্লোজারও বলা হয় এবং সাধারণত একবারের জন্য ব্যবহৃত হয়। অ্যানোনিমাস ফাংশনকে একটি ভেরিয়েবলের মধ্যে সংরক্ষণ করা যায় এবং পরে যেখানে প্রয়োজন সেখানে ব্যবহার করা যায়।

<?php

// অ্যানোনিমাস ফাংশন তৈরি করা হয়েছে এবং $greet ভেরিয়েবলের মধ্যে সংরক্ষণ করা হয়েছে
$greet = function($name) {
    // এখানে $name প্যারামিটার হিসেবে নেওয়া হয়েছে এবং একটি শুভেচ্ছা বার্তা প্রদর্শন করা হয়েছে
    return "Hello, " . $name . "!";
};

// অ্যানোনিমাস ফাংশন কল করা হচ্ছে এবং "John" নাম পাঠানো হচ্ছে
echo $greet("John"); // আউটপুট: Hello, John!

// অ্যানোনিমাস ফাংশন আবার কল করা হচ্ছে এবং "Alice" নাম পাঠানো হচ্ছে
echo $greet("Alice"); // আউটপুট: Hello, Alice!

?>



Parameters: Functions can accept parameters to work with dynamic data.
Anonymous Functions: Functions without a name that can be assigned to variables.


static 
--------------

 * স্ট্যাটিক প্রোপার্টি এবং মেথডকে স্ট্যাটিক করতে হলে, তাদের নামের পূর্বে অবশ্যই static কীওয়ার্ডটি লিখতে হয়।
 * স্ট্যাটিক মেথডকে ক্লাসের বাইরে থেকে সরাসরি scope resolution অপারেটর (::) ব্যবহার করে কল করা যায়। স্ট্যাটিক মেথড ব্যবহারের জন্য ক্লাসের ইনস্ট্যান্স তৈরি করার প্রয়োজন হয় না।
 

 class Dev {
     const AGE = 50;
    const NAME = "Obaydulla";
    public static $name = "Obaydulla";

     public static function name () {
         return "My name is " . Dev::NAME;
    }
}

$name = new Dev;
 echo $name->name(); // Method access
echo Dev::$name;    // property access



* Trait
-------------
multiple inheretence kora jai. php te multiple inheretence nai ........ ja class a dorkar sekhane  use keword diye extend korte hoi.

Example:- 
 Trait A {
    public function dev() {
        return "I am from Dev A";
    }
    public function play() {
        return "I am love to Play A";
    }
    public function game() {
        return "I am play game to A";
    }
 }

 class B {
    public function food() {
        return "I am food from B";
    }
 }

 class C extends B {
    use A;
 }

 $c = new C;
 echo $c->play();





* abstract, 
-------------------
এবস্ট্রাক্ট ক্লাস এবং মেথড:

এবস্ট্রাক্ট ক্লাস: এই ধরনের ক্লাস থেকে সরাসরি কোনো ইনস্ট্যান্স তৈরি করা যায় না (মানে, এই ক্লাসটি দিয়ে সরাসরি কোনো অবজেক্ট বানানো যায় না)। তবে এটি অন্য ক্লাসগুলোর মধ্যে ইনহেরিট করা যায়, অর্থাৎ, এর চাইল্ড ক্লাস হিসেবে ব্যবহার করা যায়।

এবস্ট্রাক্ট মেথড: এটি শুধুমাত্র একটি নকশা বা নির্দেশনা দেয়, কিন্তু এর ভেতরে কোনো কোড বা কাজের বিবরণ থাকে না। চাইল্ড ক্লাসগুলোতে এই মেথডের বাস্তবায়ন (implementation) করতে হয়।

এবস্ট্রাক্ট ক্লাস প্রোগ্রামারদের নির্দেশনা দেয় যে, চাইল্ড ক্লাসগুলোতে কি কি থাকতে হবে। এটি প্রোগ্রামিংয়ের একটি ধরণ বা গাইডলাইন হিসেবে কাজ করে।

abstract class Animal {
    // এবস্ট্রাক্ট মেথড, যার কোনো নির্দিষ্ট কাজ নেই
    abstract public function sound();
}

class Dog extends Animal {
    // Dog ক্লাসে sound() মেথডের বাস্তবায়ন
    public function sound() {
        return "Bark";
    }
}

class Cat extends Animal {
    // Cat ক্লাসে sound() মেথডের বাস্তবায়ন
    public function sound() {
        return "Meow";
    }
}

// Dog এবং Cat ক্লাসের ইনস্ট্যান্স তৈরি করা যাবে
$dog = new Dog();
echo $dog->sound(); // Output: Bark

$cat = new Cat();
echo $cat->sound(); // Output: Meow

সহজভাবে বললে:
এবস্ট্রাক্ট ক্লাস (Animal): এটি একটি নকশা বা ধারণা, যা বলছে, "যে কোনো প্রাণীকে একটি sound() মেথড থাকতে হবে।"
Dog এবং Cat: এরা Animal থেকে ইনহেরিট করা ক্লাস। Dog ঘেউ ঘেউ করে (Bark) এবং Cat মিউ মিউ করে (Meow)।

* interface
-------------------
ইন্টারফেস ক্লাস (Interface Class) : এর আগে এবস্ট্রাক্ট ক্লাস সম্পর্কে আলোচনা হয়েছে।এবস্ট্রাক্ট ক্লাস আর ইন্টারফেস ক্লাস হুবহু একই শুধু পার্থক্য হচ্ছে এবস্ট্রাক্ট ক্লাসে এবস্ট্রাক্ট মেথড ছাড়াও অন্য মেথড থাকতে পারে এবং এই মেথডের ভিতর কোড থাকতে পারে (সাধারনত এটাকে মেথড বডি বলে) আর ইন্টারফেস ক্লাসে কোন মেথডে বডি থাকতে পারবেনা।

interface onno onno class ke baddo kore kaj korar jonno...... aikhane method mody thakbe na eta implements  korte hoi not extends

example....
interface Student {
    public function dev($name, $age);
}

class Users implements Student {
    function dev($name, $age) {
        echo "I am " .$name . $age;
    }
}

$dev = new Users;

$dev->dev('interface', 20);




 * constant  ধ্রুবক মানে যা কোন পরিবর্তন নেই ।
-------------------------------------------------------
-Constants are deifend usin the define()
- const keyword is use for class constants.

define("age", 40);  // global constants

echo age;


class MyClass {
	const  age= 40;
static public $age = 700;
}

echo MyClass::age; // 40
echo MyClass:$:age; // 4700


* extends  is keyword 
--------------------------
In Laravel, the concept of "extends" refers to the use of inheritance in object-oriented programming (OOP). When you extend a class, you create a new class that inherits the properties and methods of another class. This allows you to reuse and extend functionality without duplicating code.

class Vehicle {
    public function startEngine() {
        return "Engine started";
    }
}

class Car extends Vehicle {
    public function drive() {
        return "Driving...";
    }

$car = new Car();
echo $car->startEngine(); // Output: Engine started
echo $car->drive();       // Output: Driving...


* implements
------------------------------------------







* composer ki
--------------------
 Define Composer.
Laravel is a popular web application framework that allows you to build dynamic websites and applications.

A composer is a tool that includes all the dependencies and libraries. It helps the user to develop a project concerning the mentioned framework. Third-party libraries can be installed easily using composer.

Composer is used to managing its dependencies, which are noted in the composer.json file and placed in the source folder.




Instance ki ?
---------------------

Step 1: Define a Class

class Car {
    public $color;  // Property

    // Method
    public function setColor($color) {
        $this->color = $color;
    }

    // Method
    public function getColor() {
        return $this->color;
    }
}


Step 2: Create an Instance of the Class
To create an instance of a class, use the new keyword:

 $myCar = new Car();  // Creating an instance of the Car class


Class: A template for creating objects, defining their properties and methods.
Object: An instance of a class.
Instance: A specific realization of a class, created using the new keyword.
Properties and Methods: Attributes and behaviors defined within a class that can be used by its instances.


7. Objects, class ki kamne kaj kore
======================================================
https://sattacademy.com/admission/chapter=13790/read#:~:text=PHP%3A%20Object%20%2D%20%E0%A6%85%E0%A6%AC%E0%A6%9C%E0%A7%87%E0%A6%95%E0%A7%8D%E0%A6%9F%20%E0%A6%B9%E0%A6%B2%E0%A7%8B%20%E0%A6%95%E0%A7%8D%E0%A6%B2%E0%A6%BE%E0%A6%B8,%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A6%95%E0%A7%8D%E0%A6%B0%E0%A6%BF%E0%A6%AF%E0%A6%BC%E0%A6%BE%20%E0%A6%8F%E0%A6%B0%20%E0%A6%B8%E0%A6%AE%E0%A6%A8%E0%A7%8D%E0%A6%AC%E0%A6%AF%E0%A6%BC%E0%A7%87%20%E0%A6%97%E0%A6%A0%E0%A6%BF%E0%A6%A4%20%E0%A6%B9%E0%A6%AF%E0%A6%BC%E0%A5%A4

PHP: Class - প্রোপার্টি(মেম্বার ভ্যারিয়েবল) এবং মেম্বার ফাংশন(মেথড) এর সমন্বয়ে অবজেক্ট তৈরির জন্য ক্লাস হলো সম্প্রসারণযোগ্য প্রোগ্রামিং কোড এর একটি নীল নকশা(templete)।

PHP: Object - অবজেক্ট হলো ক্লাস এর একটি বিশেষ নিদর্শন(instance) যা ভ্যারিয়েবল, ফাংশন এবং ডেটা স্ট্রাকচার এর সমন্বয়ে গঠিত হতে পারে।

PHP: Method - ক্লাস এর মেম্বার ফাংশনসমূহকে OOP তে মেথড বলা হয়। মেথড হলো অবজেক্ট-ক্লাস এর সাথে সম্পর্কিত একটি প্রক্রিয়া। একটি অবজেক্ট তথ্য এবং তথ্য প্রক্রিয়া এর সমন্বয়ে গঠিত হয়। "তথ্যকে" অবজেক্ট এর বৈশিষ্ট্য(property) এবং "তথ্য প্রক্রিয়াকে" মেথড এর মাধ্যমে প্রকাশ করা হয়। মেথড বাইরের অবজেক্ট এর সাথেও সম্পর্ক তৈরি করতে পারে।

PHP: Property - ক্লাস এর মেম্বার ভ্যারিয়েবল।

* static 
-------------
যে class er object না বানিয়ে যদি class এর বাইরে ব্যবহার করতে চাই  তাহলে static বানাতে হবে ।  static er property baire thake call kora jai na but method ke call kora jai....

static propery class ar baire  thake output dakha jai na.

static class scop rejation operator diye acces korte hoi.
In PHP, the double colon :: is called the scope resolution operator or Paamayim Nekudotayim. It is used to access static, constant, and overridden properties or methods of a class. It is also used to refer to parent classes.

Here's a breakdown of different uses of the :: operator:

1. Accessing Static Methods
Static methods are methods that belong to the class itself rather than to any specific object instance. You can call a static method using the :: operator.

class Dev {
    public static function name() {
        return "I am a static method";
    }
}

// Call the static method using the class name
echo Dev::name(); // Output: I am a static method

// Class ar vitor and bahire same waye to call korte hoi
class Dev {
    public static $age = 50;
    public static $name = "Obaydulla";

    public static function name () {
        return "My name is " . Dev::$name;
       return "My name is " . self::$name;  // we can user self that means our in our wan calss
    }

}
echo Dev::name();




10.  Namespace 
================================================================================
Namespace  -> নেমস্পেস মুলত ডিরেক্টরি বা ফাইলের লোকেশন ।
আমাদের প্রজেক্টে একই নামের কয়েকটা ক্লাস থাকতে পারে, একটা ক্লাসের সাথে আরেকোটা ক্লাস ফ্লাস না হয়ে  যায় এই জন্য Namespace ব্যাবহার করতে হয় । 

একাধিক function , class , interface , constant , trait , abstract  থাকতে পারে একটা  আরেকোটার সাথে ফ্লাস না হয় এই জন্য Namespace ব্যাবহার করতে হয় । 

laravel এর একটি ফাইল একটা নেমস্পেস হবে । বাকি গুলা use ব্যবহার করে নেমস্পেশ দেখাতে হয়  ।

আপানার লারাভেল প্যাকেজে বা অন্য যেকোনো পি এইচ পি ডেভেলপমেন্ট প্রোজেক্ট এ যদি একই নামে একাধিক function , class , interface , constant , trait , abstract থাকে তখন সমস্যা সৃষ্টি হবে । কোন টা ব্য্যবহার হচ্ছে সেটা ফিক্স করা সম্ভব না । এই সমস্যা সমাধানের জন্য নেমস্পেস ব্যবহার করা হয় ।

নেমস্পেসের মাধ্যমে ইমপোর্ট করা হয় use operator দিয়ে ।

একই নামের ২ টা ক্লাস থকলে Alias user করতে হবে  alias user kora hoi as diye।

use App\Controller\Student;
use AppSupport\Student\Student as MyStudent

$stu = new MyStudent;


Method chaining
-------------------------

 class Student {

    private $name = "Obaydulla";
    private $age = 5;
    private $dev = "Laravel Developer";


    /**
     * Set Student name
     */
     public function setName($name) {
        $this-> name = $name;
        return  $this;
     }

    /**
     * Set Student age
     */

     public function setAge($age) {
        $this-> age = $age;
        return  $this;
     }

     
    /**
     * Set Student name
     */
    public function setDev($dev) {
        $this-> dev = $dev;
        return  $this;
     }

    /**
     * info methods
     */
    public function info() {
        return "My name is ". $this->name ." & I am ". $this->age ." years old and I am a " . $this->dev ;
    }
 }

 $student = new Student;

 echo $student -> setDev("Java Developer") -> setName("Refat")->setAge(150)->info();

15
===================

Public: এটা সবার জন্য খোলা। তুমি যেকোনো জায়গা থেকে এটি ব্যবহার করতে পারো।

Private: এটা শুধু সেই ক্লাসের ভেতরে থাকা জন্য। যদি বাইরে থেকে ব্যবহার করতে চাও, তাহলে ক্লাসের ভেতরের অন্য কোনো মেথডের মাধ্যমে যেতে হবে।

Protected: এটা একটু সুরক্ষিত। শুধু সেই ক্লাস এবং যেসব ক্লাস এই ক্লাসকে "extends" করেছে, তারা এটা ব্যবহার করতে পারবে।






Satt Academy
====================================================================

পিএইচপি OOP
OOP এর পূর্ণরূপ হলঃ Object-Oriented Programming। OOP তে সবকিছুই অবজেক্ট। যেমন- আপনি আমাদের এই বিশ্বকে নিয়ে কল্পনা করতে পারেন যা চাঁদ, সূর্য, পৃথিবী ইত্যাদি অবজেক্ট নিয়ে গঠিত।

একইভাবে, আপনি একটি গাড়ি কল্পনা করতে পারেন যা চাকা, গিয়ার, ইঞ্জিন ইত্যাদি অবজেক্ট নিয়ে গঠিত।

অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং এর ধারণাও অনেকটা পথিবী এবং গাড়ির মতই। এটি সবকিছুকেই অবজেক্ট হিসাবে বিবেচনা করে। আপনি এই অবজেক্ট সমূহ ব্যবহার করে বিভিন্ন অ্যাপ্লিকেশন তৈরি করতে পারেন।

পিএইচপির ভার্সন-৪ এ অবজেক্ট অরিয়েন্টেড বৈশিষ্ট্য না থাকলেও ভার্সন-৫ এ অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং কৌশল এর সম্পূর্ণ বৈশিষ্ট্য যুক্ত হয়েছে। পিএইচপিতে অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং ব্যবহার করে অনেক বৃহৎ ও জটিল ওয়েব অ্যাপ্লিকেশন তৈরি করা সম্ভব।

পিএইচপি OOP উদাহরণ
kt_satt_skill_example_id=564

অবজেক্ট অরিয়েন্টেডের গুরুত্বপূর্ণ বিষয় বস্তু
আমরা আমাদের টিউটোরিয়ালে অবজেক্ট অরিয়েন্টেডের নিম্নোক্ত বিষয় সমূহ নিয়ে আলোচনা করবোঃ

PHP: Class - প্রোপার্টি(মেম্বার ভ্যারিয়েবল) এবং মেম্বার ফাংশন(মেথড) এর সমন্বয়ে অবজেক্ট তৈরির জন্য ক্লাস হলো সম্প্রসারণযোগ্য প্রোগ্রামিং কোড এর একটি নীল নকশা(templete)।
PHP: Object - অবজেক্ট হলো ক্লাস এর একটি বিশেষ নিদর্শন(instance) যা ভ্যারিয়েবল, ফাংশন এবং ডেটা স্ট্রাকচার এর সমন্বয়ে গঠিত হতে পারে।
PHP: Method - ক্লাস এর মেম্বার ফাংশনসমূহকে OOP তে মেথড বলা হয়। মেথড হলো অবজেক্ট-ক্লাস এর সাথে সম্পর্কিত একটি প্রক্রিয়া। একটি অবজেক্ট তথ্য এবং তথ্য প্রক্রিয়া এর সমন্বয়ে গঠিত হয়। "তথ্যকে" অবজেক্ট এর বৈশিষ্ট্য(property) এবং "তথ্য প্রক্রিয়াকে" মেথড এর মাধ্যমে প্রকাশ করা হয়। মেথড বাইরের অবজেক্ট এর সাথেও সম্পর্ক তৈরি করতে পারে।
PHP: Property - ক্লাস এর মেম্বার ভ্যারিয়েবল।
PHP: Encapsulation - প্রোপার্টি এবং মেথডসমূহ একত্রিত করে অবজেক্ট তৈরির একটি কৌশল।
PHP: Inheritance - কোড ডুপ্লিকেশন কমানোর জন্য প্যারেন্ট ক্লাস এর প্রোপার্টি এবং মেথড চাইল্ড ক্লাসও ব্যবহার করতে পারে।
PHP: Parent class - অন্য সকল ক্লাস এই ক্লাস কে ইনহেরিট করে। প্যারেন্ট ক্লাসের অপর নাম সুপার ক্লাস বা বেইজ ক্লাস।
PHP: Child Class - এই ক্লাস অন্য সকল ক্লাসকে ইনহেরিট করে। এই ক্লাসের অপর নাম সাবক্লাস বা ডিরাইভ ক্লাস।
PHP: Polymorphism - বিভিন্ন ক্লাসের যেসব মেথডসমূহ একই কাজে ব্যবহৃত হয় তাদের নামকরণ একই হওয়া।
PHP: Overloading and Overriding - অভারলোডিং তখনই ঘটে যখন একই ক্লাসে দুই বা তার অধিক মেথড এর নাম একই কিন্তু প্যারামিটার ভিন্ন হয়। Overriding এর অর্থ হলো দুটি মেথডের নাম এবং প্যারামিটার(method signature) একই। একটি মেথড থাকে প্যারেন্ট ক্লাসে এবং অপরটি থাকে চাইল্ড ক্লাসে।
PHP: abstract class and method - এটি একটি অবজেক্ট অরিয়েন্টেড প্রোগ্রামিং পদ্ধতি। এই পদ্ধতিতে একজন প্রোগ্রামার প্রাসঙ্গিক তথ্য ছাড়া সকল কিছুই লুকিয়ে রাখতে পারে। যেমন- প্যারেন্ট ক্লাসের কিছু নির্দিষ্ট মেথডে চাইল্ড ক্লাস এক্সেস নিতে পারবে এমন অঙ্গীকার করার জন্য আমরা abstract class ব্যবহার করি। কিন্তু আমরা এই অঙ্গীকার করি না যে, মেথডের মধ্যে কি ধরণের কোড থাকবে।
PHP: Interface - প্যারেন্ট ক্লাস চাইল্ড ক্লাসের সাথে এই অঙ্গীকার করে যে, মেথড বাস্তবায়নের জন্য চাইল্ড ক্লাস প্যারেন্ট ক্লাস এর abstract মেথডসমূহ এক্সেস করতে পারবে।
PHP: public, private এবং protected প্রোপার্টি - প্রোপার্টিসমূহ public, private অথবা protected হতে পারে। public অর্থ প্রোপার্টিসমূহকে যেকোন স্থান থেকে এক্সেস করা যাবে, private অর্থ শুধুমাত্র সংশ্লিষ্ট ক্লাস থেকে এক্সেস করা যাবে এবং protected অর্থ হলো সংশ্লিষ্ট ক্লাস এবং এর চাইল্ড ক্লাস থেকেও এক্সেস করা যাবে।
PHP: Public, Private এবং Protected মেথড - মেথডসমূহ public, private অথবা protected হতে পারে। public অর্থ মেথডসমূহকে যেকোন স্থান থেকে এক্সেস করা যাবে, private অর্থ শুধুমাত্র সংশ্লিষ্ট ক্লাস থেকে এক্সেস করা যাবে এবং protected অর্থ হলো সংশ্লিষ্ট ক্লাস এবং এর চাইল্ড ক্লাস থেকেও এক্সেস করা যাবে।
PHP: Constructor - পিএইচপির বিশেষ ধরণের বিল্ট-ইন মেথড। অবজেক্ট তৈরির সময় প্রোপার্টির ভ্যালু এসাইনে সম্মতি দেয়। অবজেক্ট তৈরি হলে এই মেথডটি স্বয়ংক্রিয়ভাবেই সম্পাদিত হয়। দুটি আন্ডারস্কোর(__) দিয়ে construct মেথড শুরু হয়।
PHP: Destructor - Constructor এর বিপরীত। অবজেক্ট ধ্বংশ হয়ে গেলে এটি স্বয়ংক্রিয়ভাবেই কল হয়।
PHP: Type Hinting - ফাংশন ডিক্লেয়ারেশনের সময় আরগুমেন্ট এর জন্য প্রত্যাশিত ডেটা টাইপ( (arrays, objects, interface ইত্যাদি) নির্ধারণ করে দেওয়া হয়।
PHP: Static property এবং method - নতুন অবজেক্ট তৈরি করা ছাড়াই ক্লাস এর প্রোপার্টি এবং মেথডকে এক্সেস করা যায়।
PHP: Object Cloning - অবজেক্ট এর একটি কপি তৈরি করতে ক্লোনিং ব্যবহৃত হয়।
PHP : spl_autoload_register() - প্রয়োজনীয় সকল ক্লাসকে সংশ্লিষ্ট ফাইলে স্বয়ংক্রিয়ভাবে লোড করে।
PHP: scope Resolution Operator(::) - একটি class এর static, constant এবং overridden প্রোপার্টি অথবা মেথডকে এক্সেস করতে পিএইচপি scope Resolution Operator(::) ব্যবহৃত হয়।
PHP: Magic Method __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state() এবং __clone() ফাংশনকে পিএইচপি ম্যাজিক মেথড বলা হয়।

















